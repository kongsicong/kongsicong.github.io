<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>孔小葱的博客</title>
  <meta name="author" content="kongsicong">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="孔小葱的博客"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="孔小葱的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">孔小葱的博客</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">存档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-25T01:47:50.000Z"><a href="/2015/12/25/三，opencv2-x模块core介绍（二）/">2015-12-25</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/25/三，opencv2-x模块core介绍（二）/">opencv2.x模块core介绍（二）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="u4E00_uFF0Copencv_u6A21_u5757core_u5185_u5BB9_u7B2C_u4E8C_u90E8_u5206_u2014_u2014Operations_on_Arrays_uFF08_u5BF9_u6570_u7EC4_u7684_u64CD_u4F5C_uFF09"><a href="#u4E00_uFF0Copencv_u6A21_u5757core_u5185_u5BB9_u7B2C_u4E8C_u90E8_u5206_u2014_u2014Operations_on_Arrays_uFF08_u5BF9_u6570_u7EC4_u7684_u64CD_u4F5C_uFF09" class="headerlink" title="一，opencv模块core内容第二部分——Operations on Arrays（对数组的操作）"></a>一，opencv模块core内容第二部分——Operations on Arrays（对数组的操作）</h2><p>计算机图像都是以矩阵的形式存储一个个像素点，而这些各种矩阵在计算机内存中实际上是以数组的形式真实存在的，只不过是通过类和面向对象的方式将其封装成了和matlab类似的矩阵。所以，各种对矩阵（数组）的操作也是opencv中核心内容之一。其基本功能和作用就相当于matlab中那些对矩阵操作的函数。</p>
<hr>
<h2 id="u4E8C_uFF0C_u5404_u4E2A_u64CD_u4F5C_u77E9_u9635_uFF08_u6570_u7EC4_uFF09_u7684_u51FD_u6570"><a href="#u4E8C_uFF0C_u5404_u4E2A_u64CD_u4F5C_u77E9_u9635_uFF08_u6570_u7EC4_uFF09_u7684_u51FD_u6570" class="headerlink" title="二，各个操作矩阵（数组）的函数"></a>二，各个操作矩阵（数组）的函数</h2><ul>
<li><p>abs（绝对值函数）</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C++: MatExpr <span class="literal">abs</span>(<span class="keyword">const</span> <span class="keyword">Mat</span>&amp; <span class="keyword">m</span>)</span><br><span class="line">C++: MatExpr <span class="literal">abs</span>(<span class="keyword">const</span> MatExpr&amp; <span class="keyword">e</span>)</span><br><span class="line">Parameters:	</span><br><span class="line"><span class="keyword">m</span> – <span class="keyword">matrix</span>.</span><br><span class="line"><span class="keyword">e</span> – <span class="keyword">matrix</span> expression.</span><br><span class="line">MatExpr - 就是一个<span class="keyword">Mat</span></span><br><span class="line">C = <span class="literal">abs</span>(A);</span><br></pre></td></tr></table></figure>
</li>
<li><p>absdiff(计算两个矩阵差的绝对值)</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: void <span class="function"><span class="title">absdiff</span><span class="params">(InputArray src1, InputArray src2, OutputArray dst)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>两个输入参数src1和src2都是InputArray类型的，因而src1和src2不一定是Mat类型的数据。<br>有以下几种情况:</p>
<pre><code>* src1 和src2是具有相同大小和类型的数组 `dst(I) = saturate(|src1(I) - src2(I)|)`
* src1和src2分别是数组和Scalar，并且数组的元素都是Scalar，或者数组元素通道数和Scalar相同`dat(I) = saturate(|src1(I) - src2|)`
*  与第二种情况相反`dat(I) = saturate(|src1 - src2（I）|)`
</code></pre><p>注意：当数组的深度为CV_32S时，并不会对数组进行饱和操作，然后可能计算后数据溢出，得到一个负数（即使进行了绝对值操作）</p>
<ul>
<li><p>add(矩阵相加)</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> add(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray(), <span class="keyword">int</span> dtype=-1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>addWeighted</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> addWeighted(InputArray src1, <span class="keyword">double</span> alpha, InputArray src2, <span class="keyword">double</span> beta, <span class="keyword">double</span> gamma, OutputArray dst, <span class="keyword">int</span> dtype=-1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>也就是<code>dst(I) = saturate(src1(I) * alpha + src2(I) * beta +gama)</code> </p>
<ul>
<li>bitwise_add(按位相与)<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> bitwise_and(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>也就是将数组每个元素按位相与<br><code>dst(I) = saturate(src1(I) &amp; src2(I))</code><br><code>dat(I) = saturate(src1(I) &amp; src2)</code><br><code>dat(I) = saturate(src1 &amp; src2（I）)</code></p>
<ul>
<li>bitwise_not(按位取非)<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> bitwise_not(InputArray src, OutputArray dst, InputArray mask=noArray())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>也就是将数组每个元素按位取反</p>
<ul>
<li>bitwise_or（按位相或）<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> bitwise_or(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>也就是将数组每个元素按位相或<br><code>dst(I) = saturate(src1(I) | src2(I))</code><br><code>dat(I) = saturate(src1(I) | src2)</code><br><code>dat(I) = saturate(src1 | src2（I）)</code></p>
<ul>
<li><p>bitwise_xor（按位异或）</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> bitwise_xor(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray())</span><br></pre></td></tr></table></figure>
</li>
<li><p>calcCovarMatrix</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> calcCovarMatrix(<span class="keyword">const</span> Mat* samples, <span class="keyword">int</span> nsamples, Mat&amp; covar, Mat&amp; mean, <span class="keyword">int</span> flags, <span class="keyword">int</span> ctype=CV_64F)</span><br><span class="line">C++: <span class="keyword">void</span> calcCovarMatrix(InputArray samples, OutputArray covar, OutputArray mean, <span class="keyword">int</span> flags, <span class="keyword">int</span> ctype=CV_64F)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算数组的协方差矩阵，mean是数组的均值，covar是输出的协方差矩阵，flags的值决定了输出的协方差矩阵的计算方法<br>flags 可能的取值：</p>
<pre><code>* CV_COVAR_SCRAMBLED $scale*[vects[0] - mean, vects[1] - mean, ···]^T*[vects[0] - mean, vects[1] - mean, ···]$
* CV_COVAR_NORMAL  $scale*[vects[0] - mean, vects[1] - mean, ···]*[vects[0] - mean, vects[1] - mean, ···]^T$
* CV_COVAR_USE_AVG 当flags被置为这个值时，mean将不再是输出的有输入数组计算出的均值，而是由我们提前计算好的或者是已知的均值作为参数传递进去
* CV_COVAR_SCALE 当flags被置为这个值时，输出的协方差矩阵covar将会乘上一个缩放因子scale。在norma和scrambled两种模式下的缩放因子scale都是1，只要flags补位scale模式，缩放因子都会被置为1.
* CV_COVAR_ROWS 当flags被置为这个值时，输入矩阵mat将会按行计算每一行的均值和协方差
* CV_COVAR_COLS 当flags被置为这个值时，输入矩阵mat将会按列计算每一列的均值和协方差
</code></pre><p>总之，本函数的主要作用就是计算输入数组的协方差，同时也可以计算其均值。</p>
<ul>
<li>cartToPolar<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees=<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该函数将输入数组x和y转化为极坐标形式。<br>$mangnitude(I)^2 = x(I)^2  + y(I)^2$<br>$angle(I) = atan2(y(I), x(I))[180*pi]$</p>
<ul>
<li>checkRange<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="function"><span class="keyword">bool</span> <span class="title">checkRange</span><span class="params">(InputArray a, <span class="keyword">bool</span> quiet=<span class="literal">true</span>, Point* pos=<span class="number">0</span>, <span class="keyword">double</span> minVal=-DBL_MAX, <span class="keyword">double</span> maxVal=DBL_MAX )</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该函数的作用是检查输入数组的每一个元素的值是否在有效范围内。</p>
<ul>
<li>compare<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> compare(InputArray src1, InputArray src2, OutputArray dst, <span class="keyword">int</span> cmpop)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该函数比较两个数组的每一个元素的大小或者比较一个数组和一个标量的大小<br>flag cmpop的值类型：</p>
<pre><code>* CMP_EQ src1 == src2
*  CMP_GT src1 &gt; src2
*  CMP_GE src1 &gt;= src2
*  CMP_LT src1&lt; src2
*  CMP_LE src1 &lt;= src2
*  CMP_NE src1 != src2
</code></pre><ul>
<li>completeSymm<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> completeSymm(InputOutputArray mtx, bool lowerToUpper=<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将输入矩阵（方阵）的下半或者是上半部分复制到另一半。构造了一个对称矩阵</p>
<ul>
<li>convertScaleAbs<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="function"><span class="keyword">void</span> <span class="title">convertScaleAbs</span><span class="params">(InputArray src, OutputArray dst, <span class="keyword">double</span> alpha=<span class="number">1</span>, <span class="keyword">double</span> beta=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该函数对输入数组的每个元素有三个操作。缩放（<em>scale），取绝对值（| |），转换到8bit数据。<br>`dst(I) = saturate_cast&lt; uchar&gt;(|src(I) </em> alpha +beta|)`</p>
<ul>
<li>countNonZero<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: int <span class="function"><span class="title">countNonZero</span><span class="params">(InputArray src)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算输入数组中的非零元素的个数</p>
<ul>
<li>cvarrToMat<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="function">Mat <span class="title">cvarrToMat</span><span class="params">(<span class="keyword">const</span> CvArr* arr, <span class="keyword">bool</span> copyData=<span class="literal">false</span>, <span class="keyword">bool</span> allowND=<span class="literal">true</span>, <span class="keyword">int</span> coiMode=<span class="number">0</span> )</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将CvMat，IplImage或者是CvMatND等c语言类型的结构转换为Mat</p>
<ul>
<li>dct<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> dct(InputArray src, OutputArray dst, <span class="keyword">int</span> flags=0)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对一维数组或者是二维数组执行一次正向或者是逆向的离散余弦变换<br>flags 的取值：DCT_INVERSE，对数组执行正想变换，而默认的是flags=0执行正向变换<br>                        DCT_ROWS，对输入矩阵的每一行执行正向或者是逆向变换<br>所有的可能情况：</p>
<pre><code>1. 一维数组正向变换$Y = C^{(N)}  \cdot X$
    同时$C^{(N)}_{jk}= \sqrt{\alpha_j/N} \cos \left ( \frac{\pi(2k+1)j}{2N} \right )$而且$\alpha_0=1, \alpha_j=2 for j &gt; 0.$
2. 一维数组逆向变换$X =  \left (C^{(N)} \right )^{-1}  \cdot Y =  \left (C^{(N)} \right )^T  \cdot Y$ (因为$ C^{(N)}$是正交矩阵，满足：$ C^{(N)} \cdot \left(C^{(N)}\right)^T = I$ )
3. 二维数组正向变换$Y = C^{(N)}  \cdot X  \cdot \left (C^{(N)} \right )^T$
4. 二维数组逆向变换$X =  \left (C^{(N)} \right )^T  \cdot X  \cdot C^{(N)}$ 
</code></pre><p>该函数根据输入数组的尺寸和flags的类型来决定执行何种操作。</p>
<ul>
<li>dft<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="function"><span class="keyword">void</span> <span class="title">dft</span><span class="params">(InputArray src, OutputArray dst, <span class="keyword">int</span> flags=<span class="number">0</span>, <span class="keyword">int</span> nonzeroRows=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该函数对输入浮点型数组（一维或者2维）执行向前或逆向的离散傅里叶变换<br>flags的可能取值为：<br>DFT_INVERSE， 执行逆向傅里叶变换，默认执行正向傅里叶变换<br>                                  DFT_SCALE，对结果进行缩放，通常和DFT_INVERSE一起使用<br>                                  DFT_ROWS，对输入矩阵的每一行执行傅里叶变换<br>                                  DFT_COMPLEX_OUTPUT，对实数数组执行傅里叶变换后，结果虽然是一个复数数组，但是却具有对偶性质，这样的数组可以包装成一个和原输入数组一样大小的实数数组，这种操作是默认的，而且快速。但是如果你非要使用原始的复数数组，那么就要设定这个参数了。这个函数就会产生一个原始大小的数组。<br>                                  DFT_REAL_OUTPUT，对复数数组执行傅里叶逆变换后，结果会是一个和复数数组一样大小的复数数组。但是如果输入的复数数组是一个具有复数对偶性质的数组（例如由实数数组通过 DFT_COMPLEX_OUTPUT得到的复数数组），结果就会是一个实数数组。由于函数本身不会检查输入数组的对偶性质，所以你可以传递 DFT_REAL_OUTPUT来让函数认为输入数组是对偶的，然后输出的就是实数数组了<br>nonzeroRows的作用：当该参数不为零时，函数会假定只有输入数组或者只有输出数组的第一个非零行包含非零值，然后函数就直接操作第一个非零行剩下的行了，这样会让计算速度加快，节省时间。<br>以下是离散傅里叶变换的基本公式：</p>
<pre><code>1. 一维正变换$Y = F^{(N)}  \cdot X,F^{(N)}_{jk}=\exp(-2\pi i j k/N) $ and  $i=\sqrt{-1}$
2. 一维逆变换$\begin{array}{l} X&apos;=  \left (F^{(N)} \right )^{-1}  \cdot Y =  \left (F^{(N)} \right )^*  \cdot y  \\ X = (1/N)  \cdot X, \end{array},F^*=\left(\textrm{Re}(F^{(N)})-\textrm{Im}(F^{(N)})\right)^T$
3. 二维正变换$Y = F^{(M)}  \cdot X  \cdot F^{(N)}$
4. 二维逆变换$\begin{array}{l} X&apos;=  \left (F^{(M)} \right )^*  \cdot Y  \cdot \left (F^{(N)} \right )^* \\ X =  \frac{1}{M \cdot N} \cdot X&apos; \end{array}$
</code></pre><ul>
<li>divide<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(InputArray src1, InputArray src2, OutputArray dst, <span class="keyword">double</span> scale=<span class="number">1</span>, <span class="keyword">int</span> dtype=-<span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>两个数组相除<br>具体情况有<br>$$\texttt{dst(I) = saturate(src1(I)*scale/src2(I))} $$<br>$$\texttt{dst(I) = saturate(scale/src2(I))} $$</p>
<ul>
<li>determinant<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: double <span class="function"><span class="title">determinant</span><span class="params">(InputArray mtx)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算浮点方阵的行列式（适用于小型矩阵），大型矩阵有其他更快速的算法。</p>
<ul>
<li>eigen<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C++: bool eigen(InputArray src, OutputArray eigenvalues, <span class="keyword">int</span> lowindex=-1, <span class="keyword">int</span> highindex=-1)</span><br><span class="line">C++: bool eigen(InputArray src, OutputArray eigenvalues, OutputArray eigenvectors, <span class="keyword">int</span> lowindex=-1, <span class="keyword">int</span> highindex=-1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该函数就算对称矩阵的特征值或者是特征值和特征向量</p>
<ul>
<li>exp<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: void <span class="function"><span class="title">exp</span><span class="params">(InputArray src, OutputArray dst)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对数组执行指数操作。<br>$\texttt{dst} [I] = e^{ src(I) }$</p>
<ul>
<li>extractImageCOI<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> extractImageCOI(<span class="keyword">const</span> CvArr* arr, OutputArray coiimg, <span class="keyword">int</span> coi=-1 )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>提取出选定的图像通道（该函数是从<code>c语言类型的老式图像中提取通道</code>）</p>
<ul>
<li>insertImageCOI<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> insertImageCOI(InputArray coiimg, CvArr* arr, <span class="keyword">int</span> coi=-1 )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将基于c++的选定的图像通道复制到基于c的图像数组中</p>
<ul>
<li>flip<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> flip(InputArray src, OutputArray dst, <span class="keyword">int</span> flipCode)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将一个2为数组在x或y或xy方向上进行反向<br>$$<br>\texttt{dst} <em>{ij} =<br>\left{<br>\begin{array}{l l}<br>\texttt{src} </em>{\texttt{src.rows}-i-1,j} &amp; if\;  \texttt{flipCode} = 0 \<br>\texttt{src} <em>{i, \texttt{src.cols} -j-1} &amp; if\;  \texttt{flipCode} &gt; 0 \<br>\texttt{src} </em>{ \texttt{src.rows} -i-1, \texttt{src.cols} -j-1} &amp; if\; \texttt{flipCode} &lt; 0 \<br>\end{array}<br>\right.<br>$$</p>
<ul>
<li>gemm<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> gemm(InputArray src1, InputArray src2, <span class="keyword">double</span> alpha, InputArray src3, <span class="keyword">double</span> beta, OutputArray dst, <span class="keyword">int</span> flags=0 )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>表示一个广义的数组相乘<br>$\texttt{dst} =  \texttt{alpha} \cdot \texttt{src1} ^T  \cdot \texttt{src2} +  \texttt{beta} \cdot \texttt{src3} ^T$<br>该函数可以被一个矩阵表达式替换<code>dst = alpha*src1.t()*src2 + beta*src3.t();</code></p>
<ul>
<li>getConvertElem<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C++: ConvertData getConvertElem(<span class="keyword">int</span> fromType, <span class="keyword">int</span> toType)</span><br><span class="line">C++: ConvertScaleData getConvertScaleElem(<span class="keyword">int</span> fromType, <span class="keyword">int</span> toType)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>返回一个单像素的变换值。该函数返回的是一个函数指针，该函数将一个像素值类型转到另一个类型。<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*ConvertData)(<span class="keyword">const</span> <span class="keyword">void</span>* from, <span class="keyword">void</span>* to, <span class="keyword">int</span> cn)</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*ConvertScaleData)(<span class="keyword">const</span> <span class="keyword">void</span>* from, <span class="keyword">void</span>* to, <span class="keyword">int</span> cn, <span class="built_in">double</span> alpha, <span class="built_in">double</span> beta)</span><br></pre></td></tr></table></figure></p>
<p>同时也可以对数组进行操作，只要设置cn = matrix.cols<em>matrix.rows</em>matrix.channels()。</p>
<ul>
<li>getOptimalDFTSize<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">int</span> getOptimalDFTSize(<span class="keyword">int</span> vecsize)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对一个给定的数组尺寸计算出它最好的DFT变换尺寸。</p>
<ul>
<li><p>idct，idft<br>逆余弦函数变换，逆傅里叶变换</p>
</li>
<li><p>inRange</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: void <span class="function"><span class="title">inRange</span><span class="params">(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>检查输入数组是否在另外两个数组之间<br>单通道数组：<br>$$<br>\texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0<br>$$<br>双通道数组<br>$$<br>\texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0  \land \texttt{lowerb} (I)_1  \leq \texttt{src} (I)_1 \leq  \texttt{upperb} (I)_1<br>$$</p>
<ul>
<li>invert<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">double</span> invert(InputArray src, OutputArray dst, <span class="keyword">int</span> flags=DECOMP_LU)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>求一个矩阵的逆或者是伪逆矩阵（逆矩阵的广义形式）</p>
<ul>
<li>log<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: void <span class="function"><span class="title">log</span><span class="params">(InputArray src, OutputArray dst)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>求矩阵的对数</p>
<p>$\texttt{dst} (I) =  {\log |\texttt{src}(I)| }     { if \texttt{src}(I) \ne 0  }$<br>$\texttt{dst} (I) = {\texttt{C }}                     { otherwise }$</p>
<ul>
<li>LUT<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> LUT(InputArray src, InputArray lut, OutputArray dst, <span class="keyword">int</span> interpolation=0 )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对数组执行 显示查找表（look-up table） 变换。<br>$ \texttt{dst} (I)  \leftarrow \texttt{lut(src(I) + d)}$<br>$d = {0} $ if src has depth CV_8U<br>$d = {128}$ if src has depth CV_8S</p>
<ul>
<li>magnitude<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: void <span class="function"><span class="title">magnitude</span><span class="params">(InputArray x, InputArray y, OutputArray magnitude)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算2维数组的模<br>$ \texttt{dst} (I) =  \sqrt{\texttt{x}(I)^2 + \texttt{y}(I)^2}$</p>
<ul>
<li>Mahalanobis<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: double <span class="function"><span class="title">Mahalanobis</span><span class="params">(InputArray v1, InputArray v2, InputArray icovar)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算两个数组间的马氏距离。<br>$d( \texttt{vec1} , \texttt{vec2} )= \sqrt{\sum_{i,j}{\texttt{icovar(i,j)}\cdot(\texttt{vec1}(I)-\texttt{vec2}(I))\cdot(\texttt{vec1(j)}-\texttt{vec2(j)})} }$</p>
<ul>
<li>max<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C++: MatExpr <span class="literal">max</span>(<span class="keyword">const</span> <span class="keyword">Mat</span>&amp; a, <span class="keyword">const</span> <span class="keyword">Mat</span>&amp; b)</span><br><span class="line">C++: MatExpr <span class="literal">max</span>(<span class="keyword">const</span> <span class="keyword">Mat</span>&amp; a, double s)</span><br><span class="line">C++: MatExpr <span class="literal">max</span>(double s, <span class="keyword">const</span> <span class="keyword">Mat</span>&amp; a)</span><br><span class="line">C++: void <span class="literal">max</span>(InputArray src1, InputArray src2, OutputArray dst)</span><br><span class="line">C++: void <span class="literal">max</span>(<span class="keyword">const</span> <span class="keyword">Mat</span>&amp; src1, <span class="keyword">const</span> <span class="keyword">Mat</span>&amp; src2, <span class="keyword">Mat</span>&amp; dst)</span><br><span class="line">C++: void <span class="literal">max</span>(<span class="keyword">const</span> <span class="keyword">Mat</span>&amp; src1, double src2, <span class="keyword">Mat</span>&amp; dst)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算两个数组或者一个数组和标量中的最大值<br>$\texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{src2} (I))$<br>$\texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{value} )$</p>
<ul>
<li>mean<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: Scalar <span class="function"><span class="title">mean</span><span class="params">(InputArray src, InputArray mask=noArray()</span></span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算数组的均值<br>$\begin{array}{l} N =  \sum _{I: \; \texttt{mask} (I) \ne 0} 1 \ M<em>c =  \left ( \sum </em>{I: \; \texttt{mask} (I) \ne 0}{ \texttt{mtx} (I)_c} \right )/N \end{array}$</p>
<ul>
<li>meanStdDev<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask=noArray())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算数组的均值和标准差<br>$\begin{array}{l} N =  \sum _{I, \texttt{mask} (I)  \ne 0} 1 \ \texttt{mean} <em>c =  \frac{\sum</em>{ I: \; \texttt{mask}(I) \ne 0} \texttt{src} (I)_c}{N} \ \texttt{stddev} <em>c =  \sqrt{\frac{\sum</em>{ I: \; \texttt{mask}(I) \ne 0} \left ( \texttt{src} (I)_c -  \texttt{mean} _c \right )^2}{N}} \end{array}$</p>
<ul>
<li>merge<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C++: void <span class="operator"><span class="keyword">merge</span>(const Mat* mv, <span class="keyword">size_t</span> <span class="keyword">count</span>, OutputArray dst)</span><br><span class="line"><span class="keyword">C</span>++: <span class="built_in">void</span> <span class="keyword">merge</span>(InputArrayOfArrays mv, OutputArray dst)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将一些单通道数组合并为一个多通道数组。</p>
<ul>
<li>min<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C++: MatExpr <span class="literal">min</span>(<span class="keyword">const</span> <span class="keyword">Mat</span>&amp; a, <span class="keyword">const</span> <span class="keyword">Mat</span>&amp; b)</span><br><span class="line">C++: MatExpr <span class="literal">min</span>(<span class="keyword">const</span> <span class="keyword">Mat</span>&amp; a, double s)</span><br><span class="line">C++: MatExpr <span class="literal">min</span>(double s, <span class="keyword">const</span> <span class="keyword">Mat</span>&amp; a)</span><br><span class="line">C++: void <span class="literal">min</span>(InputArray src1, InputArray src2, OutputArray dst)</span><br><span class="line">C++: void <span class="literal">min</span>(<span class="keyword">const</span> <span class="keyword">Mat</span>&amp; src1, <span class="keyword">const</span> <span class="keyword">Mat</span>&amp; src2, <span class="keyword">Mat</span>&amp; dst)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算两个数组或者是数组和标量中的最小值<br>$\texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{src2} (I))$<br>$\texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{value} )$</p>
<ul>
<li>minMaxIdx<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> minMaxIdx(InputArray src, <span class="keyword">double</span>* minVal, <span class="keyword">double</span>* maxVal, <span class="keyword">int</span>* minIdx=0, <span class="keyword">int</span>* maxIdx=0, InputArray mask=noArray())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>找到整个数组中最小的和最大的值，以及他们的索引<br>该函数只能对单通道数组进行操作，若要对多通道数组进行操作，需要提前将其分为单通道，可以用Mat::reshape()或者是extractImageCOI() , or mixChannels() , or split() 等。<br>加入输入矩阵是稀疏矩阵，最小值将会在非零元素中寻找。</p>
<ul>
<li>minMaxLoc<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> minMaxLoc(InputArray src, <span class="keyword">double</span>* minVal, <span class="keyword">double</span>* maxVal=0, Point* minLoc=0, Point* maxLoc=0, InputArray mask=noArray())</span><br><span class="line">C++: <span class="keyword">void</span> minMaxLoc(<span class="keyword">const</span> SparseMat&amp; a, <span class="keyword">double</span>* minVal, <span class="keyword">double</span>* maxVal, <span class="keyword">int</span>* minIdx=0, <span class="keyword">int</span>* maxIdx=0 )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在整个数组中找到最小值，最大值以及他们的位置。和minMaxIdx相似，不支持多通道数组。</p>
<ul>
<li>minChannels<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> mixChannels(<span class="keyword">const</span> Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, <span class="keyword">const</span> <span class="keyword">int</span>* fromTo, size_t npairs)</span><br><span class="line">C++: <span class="keyword">void</span> mixChannels(<span class="keyword">const</span> vector&lt;Mat&gt;&amp; src, vector&lt;Mat&gt;&amp; dst, <span class="keyword">const</span> <span class="keyword">int</span>* fromTo, size_t npairs)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将输入数组中指定的通道数据复制到输出数组中指定的通道中。<br>fromTo 数组：<br>from[K<em>2]表示输入矩阵数组中的输入通道索引，而from[k</em>2+1]表示输出矩阵数组中的输出通道索引。第一幅输入图像（矩阵）的通道索引被放置在是0-src[0].channels()-1,第二幅输入图像（矩阵）的通道索引被放置在是src[0].channels()-src[0].channels+src[1].channels()-1，依次类推。相同的方法也应用于输出图像数组。作为一种特殊情况，当from[k*2]是负数时，相应的输出通道被0填充。<br>有如下实例<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Mat</span> rgba( 100, 100, CV_8UC4, <span class="literal">Scalar</span>(1,2,3,4) );</span><br><span class="line"><span class="keyword">Mat</span> bgr( rgba.rows, rgba.cols, CV_8UC3 );</span><br><span class="line"><span class="keyword">Mat</span> <span class="keyword">alpha</span>( rgba.rows, rgba.cols, CV_8UC1 );</span><br><span class="line"></span><br><span class="line"><span class="comment">// forming an array of matrices is a quite efficient operation,</span></span><br><span class="line"><span class="comment">// because the matrix data is not copied, only the headers</span></span><br><span class="line"><span class="keyword">Mat</span> <span class="keyword">out</span>[] = &#123; bgr, <span class="keyword">alpha</span> &#125;;</span><br><span class="line"><span class="comment">// rgba[0] -&gt; bgr[2], rgba[1] -&gt; bgr[1],</span></span><br><span class="line"><span class="comment">// rgba[2] -&gt; bgr[0], rgba[3] -&gt; alpha[0]</span></span><br><span class="line">int from_to[] = &#123; 0,2, 1,1, 2,0, 3,3 &#125;;</span><br><span class="line">mixChannels( &amp;rgba, 1, <span class="keyword">out</span>, 2, from_to, 4 );</span><br></pre></td></tr></table></figure></p>
<p>该实例将4通道的rgba图像四个通道分别复制给了3通道的bgr和单通道的alpha。</p>
<ul>
<li>mulSpectrums<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> mulSpectrums(InputArray a, InputArray b, OutputArray c, <span class="keyword">int</span> flags, bool conjB=<span class="keyword">false</span> )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对两个傅里叶变换得到的频谱数组进行相乘运算。<br>该函数与dft（），idft（）一起被用于计算卷积（conjB=false）或者是相关性（conjB=true）。</p>
<ul>
<li>multiply<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(InputArray src1, InputArray src2, OutputArray dst, <span class="keyword">double</span> scale=<span class="number">1</span>, <span class="keyword">int</span> dtype=-<span class="number">1</span> )</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算两个数组的相乘（每个元素相乘，点乘）。<br>$\texttt{dst} (I)= \texttt{saturate} ( \texttt{scale} \cdot \texttt{src1} (I)  \cdot \texttt{src2} (I))$</p>
<ul>
<li>mulTransposed<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> mulTransposed(InputArray src, OutputArray dst, bool aTa, InputArray delta=noArray(), <span class="keyword">double</span> scale=1, <span class="keyword">int</span> dtype=-1 )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} )$<br>if aTa=true , and<br>$\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T$</p>
<ul>
<li>norm<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">double</span> norm(InputArray src1, <span class="keyword">int</span> normType=NORM_L2, InputArray mask=noArray())</span><br><span class="line">C++: <span class="keyword">double</span> norm(InputArray src1, InputArray src2, <span class="keyword">int</span> normType=NORM_L2, InputArray mask=noArray() )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算输入数组的标准基。<br>当仅有输入数组src1时<br>if normType = NORM<em>INF $norm =  {|\texttt{src1}|</em>{L_{\infty}} =  \max _I | \texttt{src1} (I)|}$<br>if normType = NORM<em>L1 $norm = { | \texttt{src1} | </em>{L_1} =  \sum _I | \texttt{src1} (I)|}$<br>if normType = NORM<em>L2 $norm = { | \texttt{src1} | </em>{L_2} =  \sqrt{\sum_I \texttt{src1}(I)^2} }$<br>当输入数组有src1 和src2时<br>if normType = NORM<em>INF $norm =  {\frac{|\texttt{src1}-\texttt{src2}|</em>{L<em>{\infty}}    }{|\texttt{src2}|</em>{L_{\infty}} }}$<br>if normType = NORM<em>L1 $norm = { \frac{|\texttt{src1}-\texttt{src2}|</em>{L<em>1} }{|\texttt{src2}|</em>{L_1}} }$<br>if normType = NORM<em>L2  $norm = { \frac{|\texttt{src1}-\texttt{src2}|</em>{L<em>2} }{|\texttt{src2}|</em>{L_2}} }$</p>
<ul>
<li><p>normalize</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> normalize(InputArray src, OutputArray dst, <span class="keyword">double</span> alpha=1, <span class="keyword">double</span> beta=0, <span class="keyword">int</span> norm_type=NORM_L2, <span class="keyword">int</span> dtype=-1, InputArray mask=noArray() )</span><br><span class="line">C++: <span class="keyword">void</span> normalize(<span class="keyword">const</span> SparseMat&amp; src, SparseMat&amp; dst, <span class="keyword">double</span> alpha, <span class="keyword">int</span> normType)</span><br></pre></td></tr></table></figure>
</li>
<li><p>PCA（主成分分析类）<br>该类用来计算一个数组集合的主要成分。这种主要成分包含了由输入数组集合计算得到的协方差矩阵的特征向量，PCA类也可以将向量和由主成分定义的新的坐标空间互相转换。在这个新的坐标系统中，每一个来自于输入集合的向量。······</p>
</li>
<li><p>phase</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees=<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算2D向量的相位（旋转角）。<br>$\texttt{angle} (I) =  \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))$<br>其计算精度大约是0.3度。</p>
<ul>
<li>polarToCart<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees=<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从输入数组的模和相位计算其直角坐标中的x和y。</p>
<ul>
<li>pow<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> pow(InputArray src, <span class="keyword">double</span> power, OutputArray dst)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算数组的幂次方<br>$\texttt{dst} (I) =  {\texttt{src}(I)^p }$  if power is integer<br>$\texttt{dst} (I) =  {|\texttt{src}(I)|^p }$ otherwise</p>
<ul>
<li><p>RNG<br>随机数生成器。</p>
</li>
<li><p>randu</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C++: template&lt;typename _Tp&gt; _Tp <span class="function"><span class="title">randu</span><span class="params">()</span></span></span><br><span class="line">C++: void <span class="function"><span class="title">randu</span><span class="params">(InputOutputArray dst, InputArray low, InputArray high)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>生成一组均匀分布的随机数组</p>
<ul>
<li>randn<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: void <span class="function"><span class="title">randn</span><span class="params">(InputOutputArray dst, InputArray mean, InputArray stddev)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>生成一组正太分布的随机数组</p>
<ul>
<li>randShuffle<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> randShuffle(InputOutputArray dst, <span class="keyword">double</span> iterFactor=1., RNG* rng=0 )¶</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将数组元素顺序打乱</p>
<ul>
<li>reduce<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> reduce(InputArray src, OutputArray dst, <span class="keyword">int</span> dim, <span class="keyword">int</span> rtype, <span class="keyword">int</span> dtype=-1 )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将一个矩阵将为一个向量。</p>
<ul>
<li>repeat<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> repeat(InputArray src, <span class="keyword">int</span> ny, <span class="keyword">int</span> nx, OutputArray dst)</span><br><span class="line">C++: Mat repeat(<span class="keyword">const</span> Mat&amp; src, <span class="keyword">int</span> ny, <span class="keyword">int</span> nx)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将一个数组（x和y方向上）重复的填充到输出数组中。</p>
<ul>
<li>scaleAdd<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> scaleAdd(InputArray src1, <span class="keyword">double</span> alpha, InputArray src2, OutputArray dst)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$\texttt{dst} (I)= \texttt{scale} \cdot \texttt{src1} (I) +  \texttt{src2} (I)$</p>
<ul>
<li>setIdentity<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> setIdentity(InputOutputArray mtx, <span class="keyword">const</span> Scalar&amp; s=Scalar(1) )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>得到一个被缩放的I矩阵。</p>
<ul>
<li>solve<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">bool</span> solve(InputArray src1, InputArray src2, OutputArray dst, <span class="keyword">int</span> flags=DECO<span class="built_in">MP_LU</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>解决一个或者多个线性系统或者最小二乘法问题。</p>
<ul>
<li>solveCubic<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: int <span class="function"><span class="title">solveCubic</span><span class="params">(InputArray coeffs, OutputArray roots)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>找到一个3次多项式的实根或者复根<br>$\texttt{coeffs} [0] x^3 +  \texttt{coeffs} [1] x^2 +  \texttt{coeffs} [2] x +  \texttt{coeffs} [3] = 0$<br>$x^3 +  \texttt{coeffs} [0] x^2 +  \texttt{coeffs} [1] x +  \texttt{coeffs} [2] = 0$</p>
<ul>
<li>solvePoly<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">double</span> solvePoly(InputArray coeffs, OutputArray roots, <span class="keyword">int</span> maxIters=300 )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$\texttt{coeffs} [n] x^{n} +  \texttt{coeffs} [n-1] x^{n-1} + … +  \texttt{coeffs} [1] x +  \texttt{coeffs} [0] = 0$<br>找到一个多项式等式的实根或者复根。</p>
<ul>
<li>sort<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> sort(InputArray src, OutputArray dst, <span class="keyword">int</span> flags)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>为一个矩阵的每行或者每列排序</p>
<ul>
<li>sortIdx<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> sortIdx(InputArray src, OutputArray dst, <span class="keyword">int</span> flags)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>为一个矩阵的每行或者每列排序</p>
<ul>
<li>split<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C++: void <span class="keyword">split</span>(<span class="keyword">const</span> <span class="keyword">Mat</span>&amp; src, <span class="keyword">Mat</span>* mvbegin)</span><br><span class="line">C++: void <span class="keyword">split</span>(InputArray <span class="keyword">m</span>, OutputArrayOfArrays mv)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将一个多通道数组分解为几个单通道数组。<br>$\texttt{mv} <a href="I">c</a> =  \texttt{src} (I)_c$</p>
<ul>
<li>sqrt</li>
<li>subtract<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="keyword">void</span> subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray(), <span class="keyword">int</span> dtype=-1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算两个数组或者一个数组和一个标量相减。</p>
<ul>
<li>SVD<br>一个为浮点类型的矩阵计算单值分解的类。</li>
<li>sum<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: Scalar <span class="function"><span class="title">sum</span><span class="params">(InputArray src)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>计算数组元素的和</p>
<ul>
<li>trace<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: Scalar <span class="function"><span class="title">trace</span><span class="params">(InputArray mtx)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>返回矩阵的迹<br>$\mathrm{tr} ( \texttt{mtx} ) =  \sum _i  \texttt{mtx} (i,i)$</p>
<ul>
<li>theRNG<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: RNG&amp; <span class="function"><span class="title">theRNG</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>返回默认的随机数生成器</p>
<ul>
<li><p>transform</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: void <span class="function"><span class="title">transform</span><span class="params">(InputArray src, OutputArray dst, InputArray m)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>transpose</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: void <span class="function"><span class="title">transpose</span><span class="params">(InputArray src, OutputArray dst)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>矩阵转置<br>$\texttt{dst} (i,j) =  \texttt{src} (j,i)$</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-24T04:57:29.000Z"><a href="/2015/12/24/二，opencv2.x模块core介绍（一）/">2015-12-24</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/24/二，opencv2.x模块core介绍（一）/">opencv2.x模块core介绍（一）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="u4E00_uFF0Copencv_u6A21_u5757core_u5185_u5BB9_u7B2C_u4E00_u90E8_u5206_u2014_u2014Basic_Structures_uFF08_u57FA_u672C_u6570_u636E_u7ED3_u6784_uFF09"><a href="#u4E00_uFF0Copencv_u6A21_u5757core_u5185_u5BB9_u7B2C_u4E00_u90E8_u5206_u2014_u2014Basic_Structures_uFF08_u57FA_u672C_u6570_u636E_u7ED3_u6784_uFF09" class="headerlink" title="一，opencv模块core内容第一部分——Basic Structures（基本数据结构）"></a>一，opencv模块core内容第一部分——Basic Structures（基本数据结构）</h2><p>该模块中包含了opencv所利用到的最基本的数据结构，是opencv最基础最核心，也是最需要掌握的内容，本章节主要介绍opencv2.x基于c++的类，只是顺带提一下opencv1.x中的基于c语言类型的数据结构。<br>opencv2.x中最基础的数据类型有如下几个：<br>DataType——数据类型<br>Point<em>,Point3</em>——点（x，y，z）<br>Size<em>——尺寸（width*heigth）<br>Rect</em>,RotatedRect——矩形（x，y，width，height）<br>TermCriteria——终止条件<br>Matx——小矩阵<br>Vec——向量<br>Scalar<em>——标量<br>Range——范围<br><code>Ptr</code>——指针(<code>重点，难点，需花时间</code>)<br><code>Mat</code>,Mat</em>——矩阵<code>（最重要，最核心，需要很多时间）</code><br>InputArray,OutputArray——输入输出数组<br>NartMatIterator——矩阵迭代<br>SparseMat,SparseMat_——稀疏矩阵<br>Algorithm——算法</p>
<hr>
<h2 id="u4E8C_uFF0CDataType"><a href="#u4E8C_uFF0CDataType" class="headerlink" title="二，DataType"></a>二，DataType</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB_uFF1A"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB_uFF1A" class="headerlink" title="数据类型简介："></a>数据类型简介：</h3><p>该类是opencv的最原始的数据类型，opencv的基本的数据类型有<code>unsigned char, bool, signed char, unsigned short, signed short, int , float, double 或者是这些类型的多个元素的组合（rgb，三通道数据类型）</code>。以上列表中任何原始数据类型都可以被<code>CV_ &lt;bit-depth&gt;{U|S|F}C(&lt;number_of_channels&gt;)</code>来定义。例如，<code>uchar——CV_8UC1，3个元素的浮点元组——CV_32FC3</code>等等。一个通用的能够存储这样一个原始数据类型的opencv结构就是Vec。这样的数据类型的实例可以被存储在std::vector, Mat, Mat<em>, SparseMat, SparseMat</em>, 或者是任何其他能偶存储Vec实例的容器类。<br><code>结论:DataType就是opencv最基本的数据类型，</code>CV_8UC1<code>之类的东西。</code></p>
<h3 id="u7C7B_u5B9A_u4E49"><a href="#u7C7B_u5B9A_u4E49" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> DataType&lt;uchar&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> uchar value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> work_type;</span><br><span class="line">    <span class="keyword">typedef</span> uchar channel_type;</span><br><span class="line">    <span class="keyword">enum</span> &#123; channel_type = CV_8U, channels = <span class="number">1</span>, fmt=<span class="string">'u'</span>, type = CV_8U &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; DataType&lt;<span class="built_in">std</span>::<span class="keyword">complex</span>&lt;_Tp&gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">complex</span>&lt;_Tp&gt; value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">complex</span>&lt;_Tp&gt; work_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp channel_type;</span><br><span class="line">    <span class="comment">// DataDepth is another helper trait class</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; depth = DataDepth&lt;_Tp&gt;::value, channels=<span class="number">2</span>,</span><br><span class="line">        fmt=(channels-<span class="number">1</span>)*<span class="number">256</span>+DataDepth&lt;_Tp&gt;::fmt,</span><br><span class="line">        type=CV_MAKETYPE(depth, channels) &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这个类的作用就是讲可确定编译时间类型的数据转化为opencv特定的可编译数据类型。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocates a 30x40 floating-point matrix</span></span><br><span class="line"><span class="function">Mat <span class="title">A</span><span class="params">(<span class="number">30</span>, <span class="number">40</span>, DataType&lt;<span class="keyword">float</span>&gt;::type)</span></span>;</span><br><span class="line"></span><br><span class="line">Mat B = Mat_&lt;<span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; &gt;(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// the statement below will print 6, 2 /*, that is depth == CV_64F, channels == 2 */</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; B.depth() &lt;&lt; <span class="string">", "</span> &lt;&lt; B.channels() &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>在平常的使用中，一般不会直接使用这个类的对象，而是直接使用<code>CV_8UC3</code>等预定义常量</p>
<hr>
<h2 id="u4E09_uFF0CPoint_2CPoint3"><a href="#u4E09_uFF0CPoint_2CPoint3" class="headerlink" title="三，Point,Point3"></a>三，Point<em>,Point3</em></h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>这两个类就是为了描述计算机图像中的点，Point<em>描述的是2维的点（x, y）（在opencv1.x中对应的是CvPoint和CvPoint2D32f）,Point3</em>描述的是3维的点(x, y, z) 。</p>
<h3 id="u7C7B_u5B9A_u4E49-1"><a href="#u7C7B_u5B9A_u4E49-1" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Point_</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// various constructors</span></span><br><span class="line">    Point_();</span><br><span class="line">    Point_(_Tp _x, _Tp _y);</span><br><span class="line">    Point_(<span class="keyword">const</span> Point_&amp; pt);</span><br><span class="line">    Point_(<span class="keyword">const</span> CvPoint&amp; pt);</span><br><span class="line">    Point_(<span class="keyword">const</span> CvPoint2D32f&amp; pt);</span><br><span class="line">    Point_(<span class="keyword">const</span> Size_&lt;_Tp&gt;&amp; sz);</span><br><span class="line">    Point_(<span class="keyword">const</span> Vec&lt;_Tp, <span class="number">2</span>&gt;&amp; v);</span><br><span class="line"></span><br><span class="line">    Point_&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Point_&amp; pt);</span><br><span class="line">    <span class="comment">//! conversion to another data type</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Point_&lt;_Tp2&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion to the old-style C structures</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvPoint</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvPoint2D32f</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">operator</span> Vec&lt;_Tp, <span class="number">2</span>&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! dot product</span></span><br><span class="line">    _<span class="function">Tp <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! dot product computed in double-precision arithmetics</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">ddot</span><span class="params">(<span class="keyword">const</span> Point_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! cross-product</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! checks whether the point is inside the specified rectangle</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">inside</span><span class="params">(<span class="keyword">const</span> Rect_&lt;_Tp&gt;&amp; r)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    _Tp x, y; <span class="comment">//&lt; the point coordinates</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中以Point_模板类为原型预定义了许多表示2维坐标点的类供我们使用：如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Point_&lt;<span class="keyword">int</span>&gt; Point2i;</span><br><span class="line"><span class="keyword">typedef</span> Point2i Point;</span><br><span class="line"><span class="keyword">typedef</span> Point_&lt;<span class="keyword">float</span>&gt; Point2f;</span><br><span class="line"><span class="keyword">typedef</span> Point_&lt;<span class="keyword">double</span>&gt; Point2d;</span><br></pre></td></tr></table></figure></p>
<p>使用范例：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Point2f</span> a(<span class="number">0</span>.3f, <span class="number">0</span>.f), b(<span class="number">0</span>.f, <span class="number">0</span>.4f);</span><br><span class="line"><span class="title">Point</span> pt = (a + b)*<span class="number">10</span>.f;</span><br><span class="line"><span class="title">cout</span> &lt;&lt; pt.x &lt;&lt; <span class="string">", "</span> &lt;&lt; pt.y &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>Point_类实例能够进行多种运算：<br>pt1 = pt2 + pt3;<br>pt1 = pt2 - pt3;<br>pt1 = pt2 <em> a;<br>pt1 = a </em> pt2;<br>pt1 += pt2;<br>pt1 -= pt2;<br>pt1 *= a;<br>double value = norm(pt); // L2 norm<br>pt1 == pt2;<br>pt1 != pt2;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Point3_</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// various constructors</span></span><br><span class="line">    Point3_();</span><br><span class="line">    Point3_(_Tp _x, _Tp _y, _Tp _z);</span><br><span class="line">    Point3_(<span class="keyword">const</span> Point3_&amp; pt);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Point3_</span><span class="params">(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt)</span></span>;</span><br><span class="line">    Point3_(<span class="keyword">const</span> CvPoint3D32f&amp; pt);</span><br><span class="line">    Point3_(<span class="keyword">const</span> Vec&lt;_Tp, <span class="number">3</span>&gt;&amp; v);</span><br><span class="line"></span><br><span class="line">    Point3_&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Point3_&amp; pt);</span><br><span class="line">    <span class="comment">//! conversion to another data type</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Point3_&lt;_Tp2&gt;() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">//! conversion to the old-style CvPoint...</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvPoint3D32f</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! conversion to cv::Vec&lt;&gt;</span></span><br><span class="line">    <span class="keyword">operator</span> Vec&lt;_Tp, <span class="number">3</span>&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! dot product</span></span><br><span class="line">    _<span class="function">Tp <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point3_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! dot product computed in double-precision arithmetics</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">ddot</span><span class="params">(<span class="keyword">const</span> Point3_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! cross product of the 2 3D points</span></span><br><span class="line">    <span class="function">Point3_ <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point3_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    _Tp x, y, z; <span class="comment">//&lt; the point coordinates</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>同样的，Point3_也预定义了一些类让我们直接使用：如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Point3_&lt;<span class="keyword">int</span>&gt; Point3i;</span><br><span class="line"><span class="keyword">typedef</span> Point3_&lt;<span class="keyword">float</span>&gt; Point3f;</span><br><span class="line"><span class="keyword">typedef</span> Point3_&lt;<span class="keyword">double</span>&gt; Point3d;</span><br></pre></td></tr></table></figure></p>
<p>点   类型的数据结构是opencv中很重要的类型之一。</p>
<hr>
<h2 id="u56DB_uFF0CSize"><a href="#u56DB_uFF0CSize" class="headerlink" title="四，Size_"></a>四，Size_</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-1"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-1" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>该数据类型主要用来表示一定大小的矩形框，它的最主要的数据成员就是width和height了。在opencv1.x中和Size_有相同作用的数据结构就是CvSize和CvSize2D32f了。</p>
<h3 id="u7C7B_u5B9A_u4E49-2"><a href="#u7C7B_u5B9A_u4E49-2" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Size_</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! various constructors</span></span><br><span class="line">    Size_();</span><br><span class="line">    Size_(_Tp _width, _Tp _height);</span><br><span class="line">    Size_(<span class="keyword">const</span> Size_&amp; sz);</span><br><span class="line">    Size_(<span class="keyword">const</span> CvSize&amp; sz);</span><br><span class="line">    Size_(<span class="keyword">const</span> CvSize2D32f&amp; sz);</span><br><span class="line">    Size_(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt);</span><br><span class="line"></span><br><span class="line">    Size_&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Size_&amp; sz);</span><br><span class="line">    <span class="comment">//! the area (width*height)</span></span><br><span class="line">    _<span class="function">Tp <span class="title">area</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion of another data type.</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Size_&lt;_Tp2&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion to the old-style OpenCV types</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvSize2D32f</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    _Tp width, height; <span class="comment">// the width and the height</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然同Point<em>一样，Size</em>也预定义了一些数据类型供我们使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Size_&lt;<span class="keyword">int</span>&gt; Size2i;</span><br><span class="line"><span class="keyword">typedef</span> Size2i Size;</span><br><span class="line"><span class="keyword">typedef</span> Size_&lt;<span class="keyword">float</span>&gt; Size2f;</span><br></pre></td></tr></table></figure></p>
<p>该数据类型时opencv中我们最常用的数据类型之一。</p>
<hr>
<h2 id="u4E94_uFF0CRect__uFF0CRotatedRect"><a href="#u4E94_uFF0CRect__uFF0CRotatedRect" class="headerlink" title="五，Rect_，RotatedRect"></a>五，Rect_，RotatedRect</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-2"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-2" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>该类则是点Point和尺寸Size的合体了，代表着一副图像中在某个特定位置的矩形框。它最主要的数据成员就是（x, y, width, height），（x, y）表示矩形框左上顶点的位置，而RotatedRect则代表着一个旋转以后的矩形框，除了和矩形框拥有相同的（x, y, width, height）以外，还多了一个angel（旋转角度）的数据成员：<br><img src="./1450936414855.png" alt="Alt text"></p>
<h3 id="u7C7B_u5B9A_u4E49-3"><a href="#u7C7B_u5B9A_u4E49-3" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Rect_</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! various constructors</span></span><br><span class="line">    Rect_();</span><br><span class="line">    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);</span><br><span class="line">    Rect_(<span class="keyword">const</span> Rect_&amp; r);</span><br><span class="line">    Rect_(<span class="keyword">const</span> CvRect&amp; r);</span><br><span class="line">    Rect_(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; org, <span class="keyword">const</span> Size_&lt;_Tp&gt;&amp; sz);</span><br><span class="line">    Rect_(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt1, <span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt2);</span><br><span class="line"></span><br><span class="line">    Rect_&amp; <span class="keyword">operator</span> = ( <span class="keyword">const</span> Rect_&amp; r );</span><br><span class="line">    <span class="comment">//! the top-left corner</span></span><br><span class="line">    Point_&lt;_Tp&gt; tl() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">//! the bottom-right corner</span></span><br><span class="line">    Point_&lt;_Tp&gt; br() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! size (width, height) of the rectangle</span></span><br><span class="line">    Size_&lt;_Tp&gt; size() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">//! area (width*height) of the rectangle</span></span><br><span class="line">    _<span class="function">Tp <span class="title">area</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion to another data type</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Rect_&lt;_Tp2&gt;() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">//! conversion to the old-style CvRect</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvRect</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! checks whether the rectangle contains the point</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    _Tp x, y, width, height; <span class="comment">//&lt; the top-left corner, as well as width and height of the rectangle</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该模版类预定义了一些类，来供我们使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Rect_&lt;<span class="keyword">int</span>&gt; Rect;</span><br></pre></td></tr></table></figure></p>
<p>该类实例能够进行多种数学运算如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rect</span> = <span class="built_in">rect</span> + <span class="built_in">point</span> (矩形位置平移)</span><br><span class="line"><span class="built_in">rect</span> = <span class="built_in">rect</span> + <span class="built_in">size</span> (扩大或缩小矩形)</span><br><span class="line"><span class="built_in">rect</span> += <span class="built_in">point</span>, <span class="built_in">rect</span> -= <span class="built_in">point</span>, <span class="built_in">rect</span> += <span class="built_in">size</span>, <span class="built_in">rect</span> -= <span class="built_in">size</span> </span><br><span class="line"><span class="built_in">rect</span> = rect1 &amp; rect2</span><br><span class="line"><span class="built_in">rect</span> = rect1 | rect2 </span><br><span class="line"><span class="built_in">rect</span> &amp;= rect1, <span class="built_in">rect</span> |= rect1 </span><br><span class="line"><span class="built_in">rect</span> == rect1, <span class="built_in">rect</span> != rect1</span><br></pre></td></tr></table></figure></p>
<p>该类型是opencv中最常用的数据类型之一。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">CV_EXPORTS</span> <span class="title">RotatedRect</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! various constructors</span></span><br><span class="line">    RotatedRect();</span><br><span class="line">    RotatedRect(<span class="keyword">const</span> Point2f&amp; center, <span class="keyword">const</span> Size2f&amp; size, <span class="keyword">float</span> angle);</span><br><span class="line">    RotatedRect(<span class="keyword">const</span> CvBox2D&amp; box);</span><br><span class="line">    <span class="comment">//! returns 4 vertices of the rectangle</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">points</span>(<span class="params">Point2f pts[]</span>) <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! returns the minimal up-right rectangle containing the rotated rectangle</span></span><br><span class="line">    <span class="function">Rect <span class="title">boundingRect</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! conversion to the old-style CvBox2D structure</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvBox2D</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</span><br><span class="line">    Point2f center; <span class="comment">//&lt; the rectangle mass center</span></span><br><span class="line">    Size2f size;    <span class="comment">//&lt; width and height of the rectangle</span></span><br><span class="line">    <span class="keyword">float</span> angle;    <span class="comment">//&lt; the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>旋转矩形使用范例如下：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Mat image(200, 200, CV_8UC3, Scalar(0))<span class="comment">;</span></span><br><span class="line">RotatedRect rRect = RotatedRect(Point2f(<span class="number">100,100</span>), Size2f(100,50), 30)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Point2f vertices[4]<span class="comment">;</span></span><br><span class="line">rRect.points(vertices)<span class="comment">;</span></span><br><span class="line">for (int i = 0<span class="comment">; i &lt; 4; i++)</span></span><br><span class="line">    line(image, vertices[i], vertices[(i+1)%4], Scalar(<span class="number">0,255,0</span>))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Rect brect = rRect.boundingRect()<span class="comment">;</span></span><br><span class="line">rectangle(image, brect, Scalar(<span class="number">255,0,0</span>))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">imshow("rectangles", image)<span class="comment">;</span></span><br><span class="line">waitKey(0)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="u516D_uFF0CMat_2C_Matx_2C_Mat_2C_SparseMat_2C_SparseMat"><a href="#u516D_uFF0CMat_2C_Matx_2C_Mat_2C_SparseMat_2C_SparseMat" class="headerlink" title="六，Mat, Matx, Mat, SparseMat, SparseMat"></a>六，<code>Mat</code>, Matx, Mat<em>, SparseMat, SparseMat</em></h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-3"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-3" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>矩阵是计算机视觉，计算机图像处理中最终要的概念。由于图像在计算机中都采用像素点来表示，一副图像是由width*height个像素点来组成，这所有的点组合起来就像是数学中的Mat（矩阵）。将矩阵的使用学好了，对于计算机图像处理，计算机视觉的认知就算是真正的开始了。毫无疑问，矩阵（Mat）这种数据类型是opencv最核心的数据类型，没有之一。然而为了应对各种图像的情况，opencv定义了多种类型的矩阵供我们使用。以下便让我一一介绍：</p>
<h3 id="u7C7B_u5B9A_u4E49-4"><a href="#u7C7B_u5B9A_u4E49-4" class="headerlink" title="类定义"></a>类定义</h3><ul>
<li>Mat（矩阵）<br>该矩阵代表着n维数字类型的单通道或者是多通道的数组类型的数据。它可以存储实数或者是复数向量和矩阵，灰度图或者彩色图，立体像素卷，向量域，点云，直方图（高维的直方图最好用稀疏矩阵SparseMat来存储）等等。数组M的数据位置被数组M.step[]定义，所以访问矩阵中的M(i0,i1,···,in-1),就可以通过如下公式访问：<figure class="highlight"><figcaption><span>= M.data + M.step[0]*i_0 + M.step[1]*i_1 + ... + M.step[M.dims-1]*i_&#123;M.dims-1&#125; ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#23545;&#20110;&#20108;&#32500;&#30697;&#38453;&#26469;&#35828;&#65292;&#35775;&#38382;&#20854;&#20013;&#30340;&#20803;&#32032;&#23601;&#26159;&#10;```addr(M_&#123;i,j&#125;) = M.data + M.step[0]*i + M.step[1]*j</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在opencv1.x中与矩阵Mat相对应的数据类型就是CvMat, IplImage, 和CvMatND等,其类定义如下：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class CV_EXPORTS Mat</span><br><span class="line">&#123;<span class="keyword"></span><br><span class="line">public</span>:</span><br><span class="line">    // ... a lot of methods ...</span><br><span class="line"><span class="keyword">    .</span>..</span><br><span class="line"></span><br><span class="line">    /*! includes several bit-fields:</span><br><span class="line">         - the magic signature</span><br><span class="line">         - continuity flag</span><br><span class="line">         - depth</span><br><span class="line">         - number of channels</span><br><span class="line">     */</span><br><span class="line">   <span class="instruction"> int </span>flags;</span><br><span class="line">    //! the<span class="instruction"> array </span>dimensionality, &gt;= 2</span><br><span class="line">   <span class="instruction"> int </span>dims;</span><br><span class="line">    //! the number of rows<span class="instruction"> and </span>columns<span class="instruction"> or </span>(-1, -1<span class="function">)</span> when the<span class="instruction"> array </span>has more than 2 dimensions</span><br><span class="line">   <span class="instruction"> int </span>rows, cols;</span><br><span class="line">    //! pointer to the data</span><br><span class="line">    uchar* data;</span><br><span class="line"></span><br><span class="line">    //! pointer to the reference counter;</span><br><span class="line">    // when<span class="instruction"> array </span>points to user-allocated data, the pointer is NULL</span><br><span class="line">    int* refcount;</span><br><span class="line"></span><br><span class="line">    // other members</span><br><span class="line"><span class="keyword">    .</span>..</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一般情况下表示一副图像只需要二维矩阵就够了，要么一个像素点事灰度值，要么一个像素点是一个向量，存储rgb三色。<br>基本的构造一个Mat对象的方法如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make a 7x7 complex matrix filled with 1+3j.</span></span><br><span class="line"><span class="keyword">Mat</span> <span class="literal">M</span>(7,7,CV_32FC2,<span class="literal">Scalar</span>(1,3));</span><br><span class="line"></span><br><span class="line"><span class="comment">// and now turn M to a 100x60 15-channel 8-bit matrix.</span></span><br><span class="line"><span class="comment">// The old content will be deallocated</span></span><br><span class="line"><span class="keyword">M</span>.create(100,60,CV_8UC(15));</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a 100x100x100 8-bit array</span></span><br><span class="line">int sz[] = &#123;100, 100, 100&#125;;</span><br><span class="line"><span class="keyword">Mat</span> bigCube(3, sz, CV_8U, <span class="keyword">Scalar</span>::all(0));</span><br><span class="line"><span class="comment">// add the 5-th row, multiplied by 3 to the 3rd row</span></span><br><span class="line"><span class="keyword">M</span>.row(3) = <span class="keyword">M</span>.row(3) + <span class="keyword">M</span>.row(5)*3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now copy the 7-th column to the 1-st column</span></span><br><span class="line"><span class="comment">// M.col(1) = M.col(7); // this will not work</span></span><br><span class="line"><span class="keyword">Mat</span> M1 = <span class="keyword">M</span>.col(1);</span><br><span class="line"><span class="keyword">M</span>.col(7).copyTo(M1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new 320x240 image</span></span><br><span class="line"><span class="keyword">Mat</span> img(Size(320,240),CV_8UC3);</span><br><span class="line"><span class="comment">// select a ROI</span></span><br><span class="line"><span class="keyword">Mat</span> roi(img, Rect(10,10,100,100));</span><br><span class="line"><span class="comment">// fill the ROI with (0,255,0) (which is green in RGB space);</span></span><br><span class="line"><span class="comment">// the original 320x240 image will be modified</span></span><br><span class="line">roi = <span class="literal">Scalar</span>(0,255,0);</span><br><span class="line"><span class="keyword">Mat</span> A = <span class="keyword">Mat</span>::eye(10, 10, CV_32S);</span><br><span class="line"><span class="comment">// extracts A columns, 1 (inclusive) to 3 (exclusive).</span></span><br><span class="line"><span class="keyword">Mat</span> B = A(<span class="keyword">Range</span>::all(), <span class="keyword">Range</span>(1, 3));</span><br><span class="line"><span class="comment">// extracts B rows, 5 (inclusive) to 9 (exclusive).</span></span><br><span class="line"><span class="comment">// that is, C ~ A(Range(5, 9), Range(1, 3))</span></span><br><span class="line"><span class="keyword">Mat</span> C = B(<span class="keyword">Range</span>(5, 9), <span class="keyword">Range</span>::all());</span><br><span class="line">Size size; Point ofs;</span><br><span class="line">C.locateROI(size, ofs);</span><br><span class="line"><span class="comment">// size will be (width=10,height=10) and the ofs will be (x=1, y=5)</span></span><br></pre></td></tr></table></figure></p>
<p>Mat的构造函数如下：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">C++: Mat::Mat()</span><br><span class="line">C++: Mat::Mat(int rows, int cols, int type)</span><br><span class="line">C++: Mat::Mat(Size size, int type)</span><br><span class="line">C++: Mat::Mat(int rows, int cols, int type, <span class="keyword">const</span> Scalar&amp; s)</span><br><span class="line">C++: Mat::Mat(Size size, int type, <span class="keyword">const</span> Scalar&amp; s)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> Mat&amp; m)</span><br><span class="line">C++: Mat::Mat(int rows, int cols, int type, void* data, size_t <span class="keyword">step</span>=AUTO_STEP)</span><br><span class="line">C++: Mat::Mat(Size size, int type, void* data, size_t <span class="keyword">step</span>=AUTO_STEP)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> Mat&amp; m, <span class="keyword">const</span> Range&amp; rowRange, <span class="keyword">const</span> Range&amp; colRange=Range::all() )</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> Mat&amp; m, <span class="keyword">const</span> Rect&amp; roi)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> CvMat* m, bool copyData=<span class="literal">false</span>)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> IplImage* img, bool copyData=<span class="literal">false</span>)</span><br><span class="line">C++: template&lt;typename T, int n&gt; <span class="keyword">explicit</span> Mat::Mat(<span class="keyword">const</span> Vec&lt;T, n&gt;&amp; vec, bool copyData=<span class="literal">true</span>)</span><br><span class="line">C++: template&lt;typename T, int m, int n&gt; <span class="keyword">explicit</span> Mat::Mat(<span class="keyword">const</span> Matx&lt;T, m, n&gt;&amp; vec, bool copyData=<span class="literal">true</span>)</span><br><span class="line">C++: template&lt;typename T&gt; <span class="keyword">explicit</span> Mat::Mat(<span class="keyword">const</span> vector&lt;T&gt;&amp; vec, bool copyData=<span class="literal">false</span>)</span><br><span class="line">C++: Mat::Mat(int ndims, <span class="keyword">const</span> int* sizes, int type)</span><br><span class="line">C++: Mat::Mat(int ndims, <span class="keyword">const</span> int* sizes, int type, <span class="keyword">const</span> Scalar&amp; s)</span><br><span class="line">C++: Mat::Mat(int ndims, <span class="keyword">const</span> int* sizes, int type, void* data, <span class="keyword">const</span> size_t* steps=<span class="number">0</span>)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> Mat&amp; m, <span class="keyword">const</span> Range* ranges)</span><br><span class="line">Parameters:	</span><br><span class="line">ndims – Array dimensionality.</span><br><span class="line">rows – Number <span class="keyword">of</span> rows <span class="keyword">in</span> a <span class="number">2</span>D array.</span><br><span class="line">cols – Number <span class="keyword">of</span> columns <span class="keyword">in</span> a <span class="number">2</span>D array.</span><br><span class="line">roi – Region <span class="keyword">of</span> interest.</span><br><span class="line">size – <span class="number">2</span>D array size: Size(cols, rows) . <span class="keyword">In</span> the Size() constructor, the number <span class="keyword">of</span> rows <span class="keyword">and</span> the number <span class="keyword">of</span> columns go <span class="keyword">in</span> the reverse <span class="keyword">order</span>.</span><br><span class="line">sizes – Array <span class="keyword">of</span> integers specifying an n-dimensional array shape.</span><br><span class="line">type – Array type. Use CV_8UC1, ..., CV_64FC4 <span class="keyword">to</span> create <span class="number">1</span>-<span class="number">4</span> channel matrices, <span class="keyword">or</span> CV_8UC(n), ..., CV_64FC(n) <span class="keyword">to</span> create multi-channel (up <span class="keyword">to</span> CV_CN_MAX channels) matrices.</span><br><span class="line">s – An <span class="keyword">optional</span> value <span class="keyword">to</span> initialize <span class="keyword">each</span> matrix element <span class="keyword">with</span>. <span class="keyword">To</span> <span class="keyword">set</span> all the matrix elements <span class="keyword">to</span> the particular value after the construction, use the assignment <span class="keyword">operator</span> Mat::<span class="keyword">operator</span>=(<span class="keyword">const</span> Scalar&amp; value) .</span><br><span class="line">data – Pointer <span class="keyword">to</span> the user data. Matrix constructors that <span class="keyword">take</span> data <span class="keyword">and</span> <span class="keyword">step</span> parameters <span class="keyword">do</span> <span class="keyword">not</span> allocate matrix data. Instead, they just initialize the matrix header that points <span class="keyword">to</span> the specified data, which means that no data <span class="keyword">is</span> copied. This operation <span class="keyword">is</span> very efficient <span class="keyword">and</span> can be used <span class="keyword">to</span> process external data <span class="keyword">using</span> OpenCV functions. The external data <span class="keyword">is</span> <span class="keyword">not</span> automatically deallocated, so you should <span class="keyword">take</span> care <span class="keyword">of</span> it.</span><br><span class="line"><span class="keyword">step</span> – Number <span class="keyword">of</span> bytes <span class="keyword">each</span> matrix row occupies. The value should include the padding bytes at the <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">each</span> row, <span class="keyword">if</span> any. <span class="keyword">If</span> the parameter <span class="keyword">is</span> missing (<span class="keyword">set</span> <span class="keyword">to</span> AUTO_STEP ), no padding <span class="keyword">is</span> assumed <span class="keyword">and</span> the actual <span class="keyword">step</span> <span class="keyword">is</span> calculated <span class="keyword">as</span> cols*elemSize() . See Mat::elemSize() .</span><br><span class="line">steps – Array <span class="keyword">of</span> ndims-<span class="number">1</span> steps <span class="keyword">in</span> <span class="keyword">case</span> <span class="keyword">of</span> a multi-dimensional array (the last <span class="keyword">step</span> <span class="keyword">is</span> always <span class="keyword">set</span> <span class="keyword">to</span> the element size). <span class="keyword">If</span> <span class="keyword">not</span> specified, the matrix <span class="keyword">is</span> assumed <span class="keyword">to</span> be continuous.</span><br><span class="line">m – Array that (<span class="keyword">as</span> a whole <span class="keyword">or</span> partly) <span class="keyword">is</span> assigned <span class="keyword">to</span> the constructed matrix. No data <span class="keyword">is</span> copied <span class="keyword">by</span> these constructors. Instead, the header pointing <span class="keyword">to</span> m data <span class="keyword">or</span> its <span class="keyword">sub</span>-array <span class="keyword">is</span> constructed <span class="keyword">and</span> associated <span class="keyword">with</span> it. The reference counter, <span class="keyword">if</span> any, <span class="keyword">is</span> incremented. So, <span class="keyword">when</span> you modify the matrix formed <span class="keyword">using</span> such a constructor, you also modify the corresponding elements <span class="keyword">of</span> m . <span class="keyword">If</span> you want <span class="keyword">to</span> have an independent copy <span class="keyword">of</span> the <span class="keyword">sub</span>-array, use Mat::clone() .</span><br><span class="line">img – Pointer <span class="keyword">to</span> the old-style IplImage image <span class="keyword">structure</span>. <span class="keyword">By</span> <span class="keyword">default</span>, the data <span class="keyword">is</span> <span class="keyword">shared</span> between the original image <span class="keyword">and</span> the <span class="keyword">new</span> matrix. But <span class="keyword">when</span> copyData <span class="keyword">is</span> <span class="keyword">set</span>, the full copy <span class="keyword">of</span> the image data <span class="keyword">is</span> created.</span><br><span class="line">vec – STL vector whose elements form the matrix. The matrix has a <span class="built_in">single</span> column <span class="keyword">and</span> the number <span class="keyword">of</span> rows equal <span class="keyword">to</span> the number <span class="keyword">of</span> vector elements. Type <span class="keyword">of</span> the matrix matches the type <span class="keyword">of</span> vector elements. The constructor can handle arbitrary types, <span class="keyword">for</span> which there <span class="keyword">is</span> a properly declared DataType . This means that the vector elements must be primitive numbers <span class="keyword">or</span> uni-type numerical tuples <span class="keyword">of</span> numbers. Mixed-type structures are <span class="keyword">not</span> supported. The corresponding constructor <span class="keyword">is</span> <span class="keyword">explicit</span>. Since STL vectors are <span class="keyword">not</span> automatically converted <span class="keyword">to</span> Mat instances, you should write Mat(vec) explicitly. Unless you copy the data <span class="keyword">into</span> the matrix ( copyData=<span class="literal">true</span> ), no <span class="keyword">new</span> elements will be added <span class="keyword">to</span> the vector because it can potentially yield vector data reallocation, <span class="keyword">and</span>, thus, the matrix data pointer will be invalid.</span><br><span class="line">copyData – Flag <span class="keyword">to</span> specify whether the underlying data <span class="keyword">of</span> the STL vector <span class="keyword">or</span> the old-style CvMat <span class="keyword">or</span> IplImage should be copied <span class="keyword">to</span> (<span class="literal">true</span>) <span class="keyword">or</span> <span class="keyword">shared</span> <span class="keyword">with</span> (<span class="literal">false</span>) the newly constructed matrix. <span class="keyword">When</span> the data <span class="keyword">is</span> copied, the allocated buffer <span class="keyword">is</span> managed <span class="keyword">using</span> Mat reference counting mechanism. <span class="keyword">While</span> the data <span class="keyword">is</span> <span class="keyword">shared</span>, the reference counter <span class="keyword">is</span> NULL, <span class="keyword">and</span> you should <span class="keyword">not</span> deallocate the data <span class="keyword">until</span> the matrix <span class="keyword">is</span> <span class="keyword">not</span> destructed.</span><br><span class="line">rowRange – Range <span class="keyword">of</span> the m rows <span class="keyword">to</span> <span class="keyword">take</span>. <span class="keyword">As</span> usual, the range start <span class="keyword">is</span> inclusive <span class="keyword">and</span> the range <span class="keyword">end</span> <span class="keyword">is</span> exclusive. Use Range::all() <span class="keyword">to</span> <span class="keyword">take</span> all the rows.</span><br><span class="line">colRange – Range <span class="keyword">of</span> the m columns <span class="keyword">to</span> <span class="keyword">take</span>. Use Range::all() <span class="keyword">to</span> <span class="keyword">take</span> all the columns.</span><br><span class="line">ranges – Array <span class="keyword">of</span> selected ranges <span class="keyword">of</span> m along <span class="keyword">each</span> dimensionality.</span><br></pre></td></tr></table></figure></p>
<p>Mat的其他各种成员方法见<a href="http://docs.opencv.org/2.4.11/modules/core/doc/basic_structures.html#mat" target="_blank" rel="external">Mat详解</a></p>
<ul>
<li>Matx（小矩阵）<br>该类型的矩阵为能够确定类型，确定尺寸和确定编译时间的小矩阵。<br>其基本定义如下；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">int</span> m, <span class="keyword">int</span> n&gt; <span class="keyword">class</span> Matx &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">1</span>, <span class="number">2</span>&gt; Matx12f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">2</span>&gt; Matx12d;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">1</span>, <span class="number">6</span>&gt; Matx16f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">6</span>&gt; Matx16d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">1</span>&gt; Matx21f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">1</span>&gt; Matx21d;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">6</span>, <span class="number">1</span>&gt; Matx61f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">1</span>&gt; Matx61d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">2</span>&gt; Matx22f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">2</span>&gt; Matx22d;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">6</span>, <span class="number">6</span>&gt; Matx66f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">6</span>&gt; Matx66d;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用范例如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matx33f <span class="title">m</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">          <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">          <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(Mat(m*m.t())) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>Mat_</p>
</li>
<li><p>SparseMat（稀疏矩阵）</p>
</li>
<li><p>SparseMat_</p>
</li>
</ul>
<hr>
<h2 id="u4E03_uFF0CVec_u548CScalar"><a href="#u4E03_uFF0CVec_u548CScalar" class="headerlink" title="七，Vec和Scalar_"></a>七，Vec和Scalar_</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-4"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-4" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>Vec是一个储存短数字类型的向量，相当于Matx的特例。<br>Scalar_是从Vec继承来的4元向量。</p>
<h3 id="u7C7B_u5B9A_u4E49-5"><a href="#u7C7B_u5B9A_u4E49-5" class="headerlink" title="类定义"></a>类定义</h3><p>Vec有许多预定义的类<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">int</span> n&gt; <span class="keyword">class</span> Vec : <span class="keyword">public</span> Matx&lt;_Tp, n, <span class="number">1</span>&gt; &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;uchar, <span class="number">2</span>&gt; Vec2b;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;uchar, <span class="number">3</span>&gt; Vec3b;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;uchar, <span class="number">4</span>&gt; Vec4b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">short</span>, <span class="number">2</span>&gt; Vec2s;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">short</span>, <span class="number">3</span>&gt; Vec3s;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">short</span>, <span class="number">4</span>&gt; Vec4s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt; Vec2i;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; Vec3i;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">int</span>, <span class="number">4</span>&gt; Vec4i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">float</span>, <span class="number">2</span>&gt; Vec2f;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">float</span>, <span class="number">3</span>&gt; Vec3f;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">float</span>, <span class="number">4</span>&gt; Vec4f;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">float</span>, <span class="number">6</span>&gt; Vec6f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">double</span>, <span class="number">2</span>&gt; Vec2d;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">double</span>, <span class="number">3</span>&gt; Vec3d;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">double</span>, <span class="number">4</span>&gt; Vec4d;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">double</span>, <span class="number">6</span>&gt; Vec6d;</span><br></pre></td></tr></table></figure></p>
<p>因为Vec的特殊性质，Vec<t,2>可以和Point<em>互相转换，而Vec<t,3>可以和Point3</t,3></em>互相转换，而Vec<t,4>则可以和CvScalar 或者是Scalar_互相转换，可以使用[]来访问Vec的数据。<br>以下是Vec的一些基本运算：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">v1</span> = <span class="literal">v2</span> + <span class="literal">v3</span></span><br><span class="line"><span class="label">v1</span> = <span class="literal">v2</span> - <span class="literal">v3</span></span><br><span class="line"><span class="label">v1</span> = <span class="literal">v2</span> * scale</span><br><span class="line"><span class="label">v1</span> = scale * <span class="literal">v2</span></span><br><span class="line"><span class="label">v1</span> = -<span class="literal">v2</span></span><br><span class="line"><span class="label">v1</span> += <span class="literal">v2</span> <span class="keyword">and </span>other augmenting operations</span><br><span class="line"><span class="label">v1</span> == <span class="literal">v2</span>, <span class="literal">v1</span> != <span class="literal">v2</span></span><br><span class="line"><span class="label">norm</span>(<span class="literal">v1</span>) (euclidean norm)</span><br></pre></td></tr></table></figure></t,4></t,2></p>
<p>因为Scalar<em>是从Vec<t,4>继承而来，而且Scalar</t,4></em>只能为4元向量。它与opencv1.x的CvScalar相对应，并且二者可以相互转化。Scalar<em>的主要作用是传递像素值。（rgbe）。<br>Scalar</em>的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Scalar_ : <span class="keyword">public</span> Vec&lt;_Tp, <span class="number">4</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! various constructors</span></span><br><span class="line">    Scalar_();</span><br><span class="line">    Scalar_(_Tp v0, _Tp v1, _Tp v2=<span class="number">0</span>, _Tp v3=<span class="number">0</span>);</span><br><span class="line">    Scalar_(<span class="keyword">const</span> CvScalar&amp; s);</span><br><span class="line">    Scalar_(_Tp v0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! returns a scalar with all elements set to v0</span></span><br><span class="line">    <span class="keyword">static</span> Scalar_&lt;_Tp&gt; all(_Tp v0);</span><br><span class="line">    <span class="comment">//! conversion to the old-style CvScalar</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvScalar</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion to another data type</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt; <span class="keyword">operator</span> Scalar_&lt;T2&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! per-element product</span></span><br><span class="line">    Scalar_&lt;_Tp&gt; mul(<span class="keyword">const</span> Scalar_&lt;_Tp&gt;&amp; t, <span class="keyword">double</span> scale=<span class="number">1</span> ) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// returns (v0, -v1, -v2, -v3)</span></span><br><span class="line">    Scalar_&lt;_Tp&gt; conj() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// returns true iff v1 == v2 == v3 == 0</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isReal</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Scalar_&lt;<span class="keyword">double</span>&gt; Scalar;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="u516B_uFF0CRange"><a href="#u516B_uFF0CRange" class="headerlink" title="八，Range"></a>八，Range</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-5"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-5" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>该数据类型顾名思义表示的是一个范围，它的主要数据成员就是start和end，它和opencv1.x中的CvSlice相对应<br>，这个类的主要作用就相当于matlab矩阵中的：运算符，可以访问矩阵中的行或者列的范围。</p>
<h3 id="u7C7B_u5B9A_u4E49-6"><a href="#u7C7B_u5B9A_u4E49-6" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CV_EXPORTS</span> <span class="title">Range</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Range();</span><br><span class="line">    Range(<span class="keyword">int</span> _start, <span class="keyword">int</span> _end);</span><br><span class="line">    Range(<span class="keyword">const</span> CvSlice&amp; slice);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Range <span class="title">all</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvSlice</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="u4E5D_uFF0CPtr"><a href="#u4E5D_uFF0CPtr" class="headerlink" title="九，Ptr"></a>九，Ptr</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-6"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-6" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>在opencv2.x介绍中，已经说明opencv具有自动内存管理的功能。其实现自动内存管理功能的最主要的方式就是通过Ptr这个指针类来实现的，它相当于c++中的shared_ptr,具有引用计数的功能，当没有任何变量引用一块内存区域时，Ptr就会自动释放这块内存区域。</p>
<h3 id="u7C7B_u5B9A_u4E49-7"><a href="#u7C7B_u5B9A_u4E49-7" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> Ptr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// default constructor</span></span><br><span class="line">    Ptr();</span><br><span class="line">    <span class="comment">// constructor that wraps the object pointer</span></span><br><span class="line">    Ptr(_Tp* _obj);</span><br><span class="line">    <span class="comment">// destructor: calls release()</span></span><br><span class="line">    ~Ptr();</span><br><span class="line">    <span class="comment">// copy constructor; increments ptr's reference counter</span></span><br><span class="line">    Ptr(<span class="keyword">const</span> Ptr&amp; ptr);</span><br><span class="line">    <span class="comment">// assignment operator; decrements own reference counter</span></span><br><span class="line">    <span class="comment">// (with release()) and increments ptr's reference counter</span></span><br><span class="line">    Ptr&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Ptr&amp; ptr);</span><br><span class="line">    <span class="comment">// increments reference counter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addref</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// decrements reference counter; when it becomes 0,</span></span><br><span class="line">    <span class="comment">// delete_obj() is called</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// user-specified custom object deletion operation.</span></span><br><span class="line">    <span class="comment">// by default, "delete obj;" is called</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete_obj</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// returns true if obj == 0;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provide access to the object fields and methods</span></span><br><span class="line">    _Tp* <span class="keyword">operator</span> -&gt; ();</span><br><span class="line">    <span class="keyword">const</span> _Tp* <span class="keyword">operator</span> -&gt; () <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the underlying object pointer;</span></span><br><span class="line">    <span class="comment">// thanks to the methods, the Ptr&lt;_Tp&gt; can be</span></span><br><span class="line">    <span class="comment">// used instead of _Tp*</span></span><br><span class="line">    <span class="keyword">operator</span> _Tp* ();</span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">const</span> _Tp*() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// the encapsulated object pointer</span></span><br><span class="line">    _Tp* obj;</span><br><span class="line">    <span class="comment">// the associated reference counter</span></span><br><span class="line">    <span class="keyword">int</span>* refcount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过使用Ptr &lt; T &gt; obj = new T()来声明一个变量，就会由Ptr来自动管理内存分配和释放。 </p>
<hr>
<h2 id="u5341_uFF0CInputArray_u548COutputArray"><a href="#u5341_uFF0CInputArray_u548COutputArray" class="headerlink" title="十，InputArray和OutputArray"></a>十，InputArray和OutputArray</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-7"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-7" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>InputArray是用来在opencv函数中用来传递只读参数的代理类。<code>typedef const _InputArray&amp; InputArray;</code>，_InputArray是一个可以通过Mat，Mat__&lt; T &gt;，Matx<t,m,n>,std::vector&lt; T &gt;,std::vector<std::vector< t="">&gt;或者std::vector&lt; Mat &gt;等数组类型的类来构造，所以当opencv函数中传递参数的数据类型不明确时，可以通过InputArray来作为代理。<br>例：<br>函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myAffineTransform</span><span class="params">(InputArray _src, OutputArray _dst, InputArray _m)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// get Mat headers for input arrays. This is O(1) operation,</span></span><br><span class="line">    <span class="comment">// unless _src and/or _m are matrix expressions.</span></span><br><span class="line">    Mat src = _src.getMat(), m = _m.getMat();</span><br><span class="line">    CV_Assert( src.type() == CV_32FC2 &amp;&amp; m.type() == CV_32F &amp;&amp; m.size() == Size(<span class="number">3</span>, <span class="number">2</span>) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [re]create the output array so that it has the proper size and type.</span></span><br><span class="line">    <span class="comment">// In case of Mat it calls Mat::create, in case of STL vector it calls vector::resize.</span></span><br><span class="line">    _dst.create(src.size(), src.type());</span><br><span class="line">    Mat dst = _dst.getMat();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.rows; i++ )</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.cols; j++ )</span><br><span class="line">        &#123;</span><br><span class="line">            Point2f pt = src.at&lt;Point2f&gt;(i, j);</span><br><span class="line">            dst.at&lt;Point2f&gt;(i, j) = Point2f(m.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>)*pt.x +</span><br><span class="line">                                            m.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>)*pt.y +</span><br><span class="line">                                            m.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">                                            m.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>)*pt.x +</span><br><span class="line">                                            m.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">1</span>)*pt.y +</span><br><span class="line">                                            m.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></std::vector<></t,m,n></p>
<p>当你使用这个函数时，可以将Mat，Mat__&lt; T &gt;，Matx<t,m,n>,std::vector&lt; T &gt;,std::vector<std::vector< t="">&gt;或者std::vector&lt; Mat &gt;中的任意一个数据类型传递进去。这个特性与c++中的多态特性有些类似。<br>而OutputArray是从InputArray继承而来的。它的功能与InputArray类似。<br>这两个数据类型都有一个共同的限制就是：不要为这两个类显示的构造实例对象。简单来说，他们应该只出现在函数的形参声明中。</std::vector<></t,m,n></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-21T02:17:40.000Z"><a href="/2015/12/21/一，opencv2.x介绍/">2015-12-21</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/21/一，opencv2.x介绍/">opencv2.x介绍</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="u4E00_uFF0Copencv_u6982_u89C8"><a href="#u4E00_uFF0Copencv_u6982_u89C8" class="headerlink" title="一，opencv概览"></a>一，opencv概览</h2><p>opencv（open source computer vision library：<a href="http://opencv.org" target="_blank" rel="external">opencv官网</a>是一个开源的计算机视觉库，该库包含了几百个计算机视觉处理算法。opencv库现阶段已经更新到3.x版本，但由于其不稳定性，故多采用opencv2.x版本。opencv1.x版本是基于c语言撰写的API，而opencv2.x是基于c++撰写的API。<br>opencv采用模块结构，这代表着该库包含了一些分享的或者是静态的库。下面就是各个主要模块的介绍：</p>
<ul>
<li>core-核心模块，该模块定义了opencv里面的基本的数据结构，包含了多维数组Mat和一些被其他模块使用的基本函数。</li>
<li>imgproc-一个图像处理模块，该模块包含了线性和非线性的图像处理滤波器，几何图像转换（缩放，仿射变换，视图弯曲，映射），彩色空间变换，直方图等等。</li>
<li>video-视频分析模块，该模块包含运动估计，背景去除和目标追踪算法。</li>
<li>calib3d-3d校准模块，该模块包含基本的多视图几何算法，单一和立体摄像机校准，目标姿势估计，立体一致性算法和3d重建元素等。</li>
<li>features2d-2d特征模块，改模块包含了显著特征检测器，描述符和描述符匹配器。</li>
<li>objdetect-目标检测模块，该模块包含了目标检测和预定义类的实例（例如faces，eyes，mugs，people，cars等等）。</li>
<li>highgui-该模块包含了一些处理视频捕获，图像和视频编码，以及一些简单的用户界面能力的易于使用的接口。</li>
<li>gpu-该模块包含了为不同的opencv模块使用的GPU加速算法。</li>
<li>其他-其他一些模块为帮助模块，例如FLANN和Google测试包装器，Python绑定等等。</li>
</ul>
<hr>
<h2 id="u4E8C_uFF0Copencv_API_u7279_u6027_u7B80_u4ECB"><a href="#u4E8C_uFF0Copencv_API_u7279_u6027_u7B80_u4ECB" class="headerlink" title="二，opencv API特性简介"></a>二，opencv API特性简介</h2><ul>
<li><p><code>cv命名空间</code><br> 所有的opencv类和函数都被放在cv namespace内了。<br> 访问opencv示例：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"opencv2/core/core.hpp"</span></span></span><br><span class="line">...</span><br><span class="line">cv::Mat H = cv::findHomography(points1, points2, CV_RANSAC, <span class="number">5</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p> 或者</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"opencv2/core/core.hpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line">...</span><br><span class="line">Mat H = findHomography(points1, points2, CV_RANSAC, <span class="number">5</span> );</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p> 一些现有的或者是未来的opencv外部命名可能会与STL或者其他库中的命名冲突，所有最好显示的使用opencv命名空间来解决冲突问题。 </p>
</li>
<li><p><code>自动内存管理</code><br> opencv自动处理所有的内存问题。<br> 首先，std::vector, Mat和其他的数据结构都有析构函数来解除已经分配出去的内存区域。但对于cv::Mat来说，这并不意味着析构函数并总是解除内存分配，因为opencv将数据共享考虑在内了。一个析构器将会减少与Mat数据内存相关的引用指针数量，当引用数量降到0时意味着没有变量再使用这块内存，从而这块内存会被释放。相似的，当一个Mat实例被复制的时候，其实并没有真的开辟一块新的内存空间来存储数据，而是引用数量＋1，而该引用是这个数据块的另一个拥有者。但是可以使用Mat::clone（）函数来创造一个新的内存区域存储数据。<br> 如下代码会帮助你更好的理解其中的内涵：</p>
 <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a big 8Mb matrix</span></span><br><span class="line"><span class="keyword">Mat</span> A(1000, 1000, CV_64F);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create another header for the same matrix;</span></span><br><span class="line"><span class="comment">// this is an instant operation, regardless of the matrix size.</span></span><br><span class="line"><span class="keyword">Mat</span> B = A;</span><br><span class="line"><span class="comment">// create another header for the 3-rd row of A; no data is copied either</span></span><br><span class="line"><span class="keyword">Mat</span> C = B.row(3);</span><br><span class="line"><span class="comment">// now create a separate copy of the matrix</span></span><br><span class="line"><span class="keyword">Mat</span> <span class="keyword">D</span> = B.clone();</span><br><span class="line"><span class="comment">// copy the 5-th row of B to C, that is, copy the 5-th row of A</span></span><br><span class="line"><span class="comment">// to the 3-rd row of A.</span></span><br><span class="line">B.row(5).copyTo(C);</span><br><span class="line"><span class="comment">// now let A and D share the data; after that the modified version</span></span><br><span class="line"><span class="comment">// of A is still referenced by B and C.</span></span><br><span class="line">A = <span class="keyword">D</span>;</span><br><span class="line"><span class="comment">// now make B an empty matrix (which references no memory buffers),</span></span><br><span class="line"><span class="comment">// but the modified version of A will still be referenced by C,</span></span><br><span class="line"><span class="comment">// despite that C is just a single row of the original A</span></span><br><span class="line">B.release();</span><br><span class="line"></span><br><span class="line"><span class="comment">// finally, make a full copy of C. As a result, the big modified</span></span><br><span class="line"><span class="comment">// matrix will be deallocated, since it is not referenced by anyone</span></span><br><span class="line">C = C.clone();</span><br></pre></td></tr></table></figure>
<p> 因此，使用Mat和其他一些基础的数据结构是非常容易的。但是还有其他一些高水平数据或者是用户自定义的数据类型（没有自动内存管理功能）呢？opencv为此提供了Ptr&lt;&gt;这个模板类来解决问题，该类与std::shared_ptr类似。<br> 所以在使用其他数据类型时：不用T* ptr = new T(…); 而是使用Ptr<t> ptr = new T(…);<br> 详情请看<a href="http://docs.opencv.org/2.4.11/modules/core/doc/basic_structures.html#Ptr" target="_blank" rel="external">Ptr&lt;&gt;</a>解析</t></p>
</li>
<li><p><code>输出数据的自动内存分配</code><br> opencv自动解除内存分配，同样在大多数时候也会自动为输出函数参数自动分配内存。因此如果一个函数拥有一个或者多个输入数组（cv::Mat instances） 和一些输出数组，输出数组会自动的分配或者重新分配内存。输出数组的大小和类型都由输入数组的大小和类型决定。如果需要的话，函数还会采用额外的参数来帮助计算输出数组的性质。如以下例子：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"cv.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"highgui.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!cap.isOpened()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Mat frame, edges;</span><br><span class="line">    namedWindow(<span class="string">"edges"</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        cap &gt;&gt; frame;</span><br><span class="line">        cvtColor(frame, edges, CV_BGR2GRAY);</span><br><span class="line">        GaussianBlur(edges, edges, Size(<span class="number">7</span>,<span class="number">7</span>), <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line">        Canny(edges, edges, <span class="number">0</span>, <span class="number">30</span>, <span class="number">3</span>);</span><br><span class="line">        imshow(<span class="string">"edges"</span>, edges);</span><br><span class="line">        <span class="keyword">if</span>(waitKey(<span class="number">30</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其中数组frame是由&gt;&gt;操作符自动分配内存的。因为对于视频捕获模块来说视频frame的分辨率和位深度都是未知的。数组edges是由cvtColor函数自动分配内存的。edges和输入数组frame有相同的大小和位深度。而因为彩色变换码CV_BGR2GRAY被传递到函数中所以edges的通道数为1。同时应该注意到frame和edges只有在循环中的第一次执行时才被分配内存，因为从此以后的所有视频frame都有相同的分辨率。如果你改变了视频分辨率，那数组frame则会再次自动重新分配内存。<br> 这个技术的关键部分就是Mat::create 函数，该函数将需要的数组大小和类型都利用了，如果数组已经有了特定的大小和类型，该方法什么都不会做。相反，他会释放已经分配的内存然后重新分配一块要求大小的新的内存。大多数的函数都会为输出数组调用Mat::create方法，然后就实现了为输出数组自动分配内存。<br> 来自于这个方案的一些值得注意的异常就是cv::minChannels, cv::RNG::fill以及一些其他的函数和方法。他们并不能为输出数组自动分配内存，所以你必须自己提前完成这个工作。</p>
</li>
<li><code>饱和算法</code><br> opencv作为一个计算机视觉库，它经常处理一些图像像素，这些像素常被编码为每通道8或者16比特因此他们得数值范围有限制。例如对图像进行特性操作，如彩色空间变换，亮度加强，对齐，锐化以及复杂的插值操作都会产生超出允许范围的数值。如果你仅仅用最低的8位或者16位来存储结果，这些结果可能会影响进一步的图像分析。为了解决这个问题，被称作饱和算法的东西就出现了。例如，为了存储r（一个操作的结果数据）到8位深度的图像里，你发现在0~255内最近的值：<br> I(x,y)= min ( max (round(r), 0), 255);<br> 相似的法则被应用到有符号8位，有符号16位以及无符号数据类型中了。这种语义在opencv库中到处都有使用。在c++中，会采用saturate_cast&lt;&gt;函数（类似于标准c++的转换操作），如以下例子：<br> I.at<uchar>(y, x) = saturate_cast<uchar>(r);<br> cv::uchar是opencv的8位无符号整型数据类型。<br> 注意：饱和算法并不会作用于32位的整型结果。</uchar></uchar></li>
<li><code>固定像素类型，模板的限制使用</code><br> 模板是c++的一个重大特性，该特性提供了非常强有力的高效的而且安全的数据结构和算法的实现。然而，模板的扩展使可能会增加编译时间和代码量。除此之外，当模板被独立使用的时候接口和实现将会很难分离。对于基本的算法来说这样很好，但是对于一个算法可能包含几千行代码的计算机视觉库来说这样并不友好。为了简化与其他语言（如Python，java，matlab这些可能没有模板或只有有限的模板能力的语言）的绑定发展，现今的opencv实现是基于多态和运行时分配而非模板。在那些运行时分配可能会很慢的地方（如像素访问运算符），或者不可能（如通用的Ptr&lt;&gt;的实现）或者非常不方便（如saturate_cast&lt;&gt;）现在的实现介绍了一些小型的模板类，方法和函数。而opencv中任何其他地方使用模板都是收到限制的。<br> 因此，只有有限的固定的原始数据类型可以被opencv库操作。如下：<ul>
<li>8-bit unsigned integer (uchar)</li>
<li>8-bit signed integer (schar)</li>
<li>8-bit signed integer (schar)</li>
<li>16-bit signed integer (short)</li>
<li>32-bit signed integer (int)</li>
<li>32-bit floating-point number (float)</li>
<li>64-bit floating-point number (double)</li>
<li>一些元素（像素点）包含多个相同数据类型的元素被称为多通道数组，与单通道数组相对应。opencv中最大的可能的通道数被CV_CN_MAX常量设置为512.<br>对于这些基本类型，会应用以下枚举常量：<br>enum { CV_8U=0, CV_8S=1, CV_16U=2, CV_16S=3, CV_32S=4, CV_32F=5, CV_64F=6 };<br>而多通道类型可以用以下选择方式决定：</li>
<li>CV_8UC1 … CV_64FC4 常量(通道数为1-4)</li>
<li>CV_8UC(n) … CV_64FC(n) or CV_MAKETYPE(CV_8U, n) … CV_MAKETYPE(CV_64F, n) 宏，当通道数超过4或者在编译时无法确定<br>范例：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mat <span class="function">mtx</span>(3, 3, CV_32F); <span class="comment">// make a 3x3 floating-point matrix</span></span><br><span class="line">Mat <span class="function">cmtx</span>(10, 1, CV_64FC2); <span class="comment">// make a 10x1 2-channel floating-point</span></span><br><span class="line">                           <span class="comment">// matrix (10-element complex vector)</span></span><br><span class="line">Mat <span class="function">img</span>(<span class="function">Size</span>(1920, 1080), CV_8UC3); <span class="comment">// make a 3-channel (color) image</span></span><br><span class="line">                                    <span class="comment">// of 1920 columns and 1080 rows.</span></span><br><span class="line">Mat <span class="function">grayscale</span>(image<span class="class">.size</span>(), <span class="function">CV_MAKETYPE</span>(image<span class="class">.depth</span>(), 1)); <span class="comment">// make a 1-channel image of</span></span><br><span class="line">                                                            <span class="comment">// the same size and same</span></span><br><span class="line">                                                            <span class="comment">// channel type as img</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>而拥有更复杂元素的数组是无法被opencv库构造和处理的。另外，每个函数和方法都只能够处理所有可能的数组类型中的一部分。通常情况下算法越复杂，能够支持的数据格式越少。<br>以下是一些典型的例子：</p>
<pre><code>* 人脸检测算法只能处理8位的灰度图或者彩色图
* 线性代数函数和大多数的机器学习算法都只能处理浮点类型的数组。
* 基本的函数如cv::add，支持所有的数据类型
* 彩色空间转换函数支持8位无符号整数，16位无符号整数和32位浮点类型。
</code></pre><p>每个函数的支持类型的子集都已经从实践需要中预定义了，而且可能在未来因为新的需要而扩展。</p>
<ul>
<li><code>输入数组和输出数组</code><br> 许多opencv的函数处理2维和多维的数字数组。通常，一些函数采用cpp::class:Mat 作为参数，但是在一些情况下，使用std::vector(例如一个指针集合) 或者Matx&lt;&gt;（例如一个3*3矩阵）是更方便的。为了避免API中的过多的复制，特殊的“代理proxy”类便出现了。最基本的“代理”类是InputArray，在一个函数输入中，他被用于传递只读数组，从InputArrray派生出来的OutputArray类被用于为一个函数确定一个输出数组。通常，你不需要关注其内在类型，它将会自动工作。你可以假设不是使用InputArray和OutputArray，而是使用Mat, std::vector&lt;&gt;, Matx&lt;&gt;, 或者是标量。当一个函数有可选的输入或者输出数组时，你没有该数组，可以传递cv::noArray()。</li>
<li><p><code>错误处理</code><br> opencv使用exceptions来标识重要的错误。当输入数据有一个正确的格式而且属于特定的值范围，但是因为某些原因（如最优化算法没有收敛）算法不能成功执行，它会返回一个特殊的错误码（典型情况是一个boolean值）。<br> exceptions可以是cv::Exception 类或者是它的派生类，而cv::Exception 是std::Exception的派生类。所以它可以在代码中使用标准c++库中的部分优雅的处理。<br> exception 是典型的使用CV_Error(errcode, description)宏，或者它的CV<em>Error</em>(errcode, printf-spec, (printf-args)),或者CV_Assert(condition)宏。对于性能至关重要的代码，使用CV_DbgAssert(condition)。因为自动内存分配，为了防止突然间的错误所有的内部的内存区都是自动解除分配：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// call OpenCV</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( cv::Exception&amp; e )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* err_msg = e.what();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"exception caught: "</span> &lt;&lt; err_msg &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>多线程</code><br> 当前opencv的实现是 re-enterable  ，就是说，相同的函数，一个类实例的相同的常量方法，或者不同的类的相同的非常量方法都可以在不同的线程中被调用。相同的cv::Mat可以在不同的线程中被使用，因为引用计数操作使用了the architecture-specific atomic instructions.</p>
</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-16T13:06:24.540Z"><a href="/2015/12/16/hello-world/">2015-12-16</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/16/hello-world/">Hello World</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/opencv2-x-学习笔记/">opencv2.x 学习笔记</a><small>3</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 kongsicong
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>