<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>孔小葱的博客</title>
  <meta name="author" content="kongsicong">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="孔小葱的博客"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="孔小葱的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">孔小葱的博客</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">存档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-24T04:57:29.000Z"><a href="/2015/12/24/二，opencv2-x模块core介绍（一）/">2015-12-24</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/24/二，opencv2-x模块core介绍（一）/">opencv2.x模块core介绍（一）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="u4E00_uFF0Copencv_u6A21_u5757core_u5185_u5BB9_u7B2C_u4E00_u90E8_u5206_u2014_u2014Basic_Structures_uFF08_u57FA_u672C_u6570_u636E_u7ED3_u6784_uFF09"><a href="#u4E00_uFF0Copencv_u6A21_u5757core_u5185_u5BB9_u7B2C_u4E00_u90E8_u5206_u2014_u2014Basic_Structures_uFF08_u57FA_u672C_u6570_u636E_u7ED3_u6784_uFF09" class="headerlink" title="一，opencv模块core内容第一部分——Basic Structures（基本数据结构）"></a>一，opencv模块core内容第一部分——Basic Structures（基本数据结构）</h2><p>该模块中包含了opencv所利用到的最基本的数据结构，是opencv最基础最核心，也是最需要掌握的内容，本章节主要介绍opencv2.x基于c++的类，只是顺带提一下opencv1.x中的基于c语言类型的数据结构。<br>opencv2.x中最基础的数据类型有如下几个：<br>DataType——数据类型<br>Point<em>,Point3</em>——点（x，y，z）<br>Size<em>——尺寸（width*heigth）<br>Rect</em>,RotatedRect——矩形（x，y，width，height）<br>TermCriteria——终止条件<br>Matx——小矩阵<br>Vec——向量<br>Scalar<em>——标量<br>Range——范围<br><code>Ptr</code>——指针(<code>重点，难点，需花时间</code>)<br><code>Mat</code>,Mat</em>——矩阵<code>（最重要，最核心，需要很多时间）</code><br>InputArray,OutputArray——输入输出数组<br>NartMatIterator——矩阵迭代<br>SparseMat,SparseMat_——稀疏矩阵<br>Algorithm——算法</p>
<hr>
<h2 id="u4E8C_uFF0CDataType"><a href="#u4E8C_uFF0CDataType" class="headerlink" title="二，DataType"></a>二，DataType</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB_uFF1A"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB_uFF1A" class="headerlink" title="数据类型简介："></a>数据类型简介：</h3><p>该类是opencv的最原始的数据类型，opencv的基本的数据类型有<code>unsigned char, bool, signed char, unsigned short, signed short, int , float, double 或者是这些类型的多个元素的组合（rgb，三通道数据类型）</code>。以上列表中任何原始数据类型都可以被<code>CV_ &lt;bit-depth&gt;{U|S|F}C(&lt;number_of_channels&gt;)</code>来定义。例如，<code>uchar——CV_8UC1，3个元素的浮点元组——CV_32FC3</code>等等。一个通用的能够存储这样一个原始数据类型的opencv结构就是Vec。这样的数据类型的实例可以被存储在std::vector, Mat, Mat<em>, SparseMat, SparseMat</em>, 或者是任何其他能偶存储Vec实例的容器类。<br><code>结论:DataType就是opencv最基本的数据类型，</code>CV_8UC1<code>之类的东西。</code></p>
<h3 id="u7C7B_u5B9A_u4E49"><a href="#u7C7B_u5B9A_u4E49" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> DataType&lt;uchar&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> uchar value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> work_type;</span><br><span class="line">    <span class="keyword">typedef</span> uchar channel_type;</span><br><span class="line">    <span class="keyword">enum</span> &#123; channel_type = CV_8U, channels = <span class="number">1</span>, fmt=<span class="string">'u'</span>, type = CV_8U &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; DataType&lt;<span class="built_in">std</span>::<span class="keyword">complex</span>&lt;_Tp&gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">complex</span>&lt;_Tp&gt; value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">complex</span>&lt;_Tp&gt; work_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp channel_type;</span><br><span class="line">    <span class="comment">// DataDepth is another helper trait class</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; depth = DataDepth&lt;_Tp&gt;::value, channels=<span class="number">2</span>,</span><br><span class="line">        fmt=(channels-<span class="number">1</span>)*<span class="number">256</span>+DataDepth&lt;_Tp&gt;::fmt,</span><br><span class="line">        type=CV_MAKETYPE(depth, channels) &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这个类的作用就是讲可确定编译时间类型的数据转化为opencv特定的可编译数据类型。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocates a 30x40 floating-point matrix</span></span><br><span class="line"><span class="function">Mat <span class="title">A</span><span class="params">(<span class="number">30</span>, <span class="number">40</span>, DataType&lt;<span class="keyword">float</span>&gt;::type)</span></span>;</span><br><span class="line"></span><br><span class="line">Mat B = Mat_&lt;<span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; &gt;(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// the statement below will print 6, 2 /*, that is depth == CV_64F, channels == 2 */</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; B.depth() &lt;&lt; <span class="string">", "</span> &lt;&lt; B.channels() &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>在平常的使用中，一般不会直接使用这个类的对象，而是直接使用<code>CV_8UC3</code>等预定义常量</p>
<hr>
<h2 id="u4E09_uFF0CPoint_2CPoint3"><a href="#u4E09_uFF0CPoint_2CPoint3" class="headerlink" title="三，Point,Point3"></a>三，Point<em>,Point3</em></h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>这两个类就是为了描述计算机图像中的点，Point<em>描述的是2维的点（x, y）（在opencv1.x中对应的是CvPoint和CvPoint2D32f）,Point3</em>描述的是3维的点(x, y, z) 。</p>
<h3 id="u7C7B_u5B9A_u4E49-1"><a href="#u7C7B_u5B9A_u4E49-1" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Point_</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// various constructors</span></span><br><span class="line">    Point_();</span><br><span class="line">    Point_(_Tp _x, _Tp _y);</span><br><span class="line">    Point_(<span class="keyword">const</span> Point_&amp; pt);</span><br><span class="line">    Point_(<span class="keyword">const</span> CvPoint&amp; pt);</span><br><span class="line">    Point_(<span class="keyword">const</span> CvPoint2D32f&amp; pt);</span><br><span class="line">    Point_(<span class="keyword">const</span> Size_&lt;_Tp&gt;&amp; sz);</span><br><span class="line">    Point_(<span class="keyword">const</span> Vec&lt;_Tp, <span class="number">2</span>&gt;&amp; v);</span><br><span class="line"></span><br><span class="line">    Point_&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Point_&amp; pt);</span><br><span class="line">    <span class="comment">//! conversion to another data type</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Point_&lt;_Tp2&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion to the old-style C structures</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvPoint</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvPoint2D32f</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">operator</span> Vec&lt;_Tp, <span class="number">2</span>&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! dot product</span></span><br><span class="line">    _<span class="function">Tp <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! dot product computed in double-precision arithmetics</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">ddot</span><span class="params">(<span class="keyword">const</span> Point_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! cross-product</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! checks whether the point is inside the specified rectangle</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">inside</span><span class="params">(<span class="keyword">const</span> Rect_&lt;_Tp&gt;&amp; r)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    _Tp x, y; <span class="comment">//&lt; the point coordinates</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中以Point_模板类为原型预定义了许多表示2维坐标点的类供我们使用：如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Point_&lt;<span class="keyword">int</span>&gt; Point2i;</span><br><span class="line"><span class="keyword">typedef</span> Point2i Point;</span><br><span class="line"><span class="keyword">typedef</span> Point_&lt;<span class="keyword">float</span>&gt; Point2f;</span><br><span class="line"><span class="keyword">typedef</span> Point_&lt;<span class="keyword">double</span>&gt; Point2d;</span><br></pre></td></tr></table></figure></p>
<p>使用范例：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Point2f</span> a(<span class="number">0</span>.3f, <span class="number">0</span>.f), b(<span class="number">0</span>.f, <span class="number">0</span>.4f);</span><br><span class="line"><span class="title">Point</span> pt = (a + b)*<span class="number">10</span>.f;</span><br><span class="line"><span class="title">cout</span> &lt;&lt; pt.x &lt;&lt; <span class="string">", "</span> &lt;&lt; pt.y &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>Point_类实例能够进行多种运算：<br>pt1 = pt2 + pt3;<br>pt1 = pt2 - pt3;<br>pt1 = pt2 <em> a;<br>pt1 = a </em> pt2;<br>pt1 += pt2;<br>pt1 -= pt2;<br>pt1 *= a;<br>double value = norm(pt); // L2 norm<br>pt1 == pt2;<br>pt1 != pt2;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Point3_</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// various constructors</span></span><br><span class="line">    Point3_();</span><br><span class="line">    Point3_(_Tp _x, _Tp _y, _Tp _z);</span><br><span class="line">    Point3_(<span class="keyword">const</span> Point3_&amp; pt);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Point3_</span><span class="params">(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt)</span></span>;</span><br><span class="line">    Point3_(<span class="keyword">const</span> CvPoint3D32f&amp; pt);</span><br><span class="line">    Point3_(<span class="keyword">const</span> Vec&lt;_Tp, <span class="number">3</span>&gt;&amp; v);</span><br><span class="line"></span><br><span class="line">    Point3_&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Point3_&amp; pt);</span><br><span class="line">    <span class="comment">//! conversion to another data type</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Point3_&lt;_Tp2&gt;() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">//! conversion to the old-style CvPoint...</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvPoint3D32f</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! conversion to cv::Vec&lt;&gt;</span></span><br><span class="line">    <span class="keyword">operator</span> Vec&lt;_Tp, <span class="number">3</span>&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! dot product</span></span><br><span class="line">    _<span class="function">Tp <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point3_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! dot product computed in double-precision arithmetics</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">ddot</span><span class="params">(<span class="keyword">const</span> Point3_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! cross product of the 2 3D points</span></span><br><span class="line">    <span class="function">Point3_ <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point3_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    _Tp x, y, z; <span class="comment">//&lt; the point coordinates</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>同样的，Point3_也预定义了一些类让我们直接使用：如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Point3_&lt;<span class="keyword">int</span>&gt; Point3i;</span><br><span class="line"><span class="keyword">typedef</span> Point3_&lt;<span class="keyword">float</span>&gt; Point3f;</span><br><span class="line"><span class="keyword">typedef</span> Point3_&lt;<span class="keyword">double</span>&gt; Point3d;</span><br></pre></td></tr></table></figure></p>
<p>点   类型的数据结构是opencv中很重要的类型之一。</p>
<hr>
<h2 id="u56DB_uFF0CSize"><a href="#u56DB_uFF0CSize" class="headerlink" title="四，Size_"></a>四，Size_</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-1"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-1" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>该数据类型主要用来表示一定大小的矩形框，它的最主要的数据成员就是width和height了。在opencv1.x中和Size_有相同作用的数据结构就是CvSize和CvSize2D32f了。</p>
<h3 id="u7C7B_u5B9A_u4E49-2"><a href="#u7C7B_u5B9A_u4E49-2" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Size_</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! various constructors</span></span><br><span class="line">    Size_();</span><br><span class="line">    Size_(_Tp _width, _Tp _height);</span><br><span class="line">    Size_(<span class="keyword">const</span> Size_&amp; sz);</span><br><span class="line">    Size_(<span class="keyword">const</span> CvSize&amp; sz);</span><br><span class="line">    Size_(<span class="keyword">const</span> CvSize2D32f&amp; sz);</span><br><span class="line">    Size_(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt);</span><br><span class="line"></span><br><span class="line">    Size_&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Size_&amp; sz);</span><br><span class="line">    <span class="comment">//! the area (width*height)</span></span><br><span class="line">    _<span class="function">Tp <span class="title">area</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion of another data type.</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Size_&lt;_Tp2&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion to the old-style OpenCV types</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvSize2D32f</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    _Tp width, height; <span class="comment">// the width and the height</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然同Point<em>一样，Size</em>也预定义了一些数据类型供我们使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Size_&lt;<span class="keyword">int</span>&gt; Size2i;</span><br><span class="line"><span class="keyword">typedef</span> Size2i Size;</span><br><span class="line"><span class="keyword">typedef</span> Size_&lt;<span class="keyword">float</span>&gt; Size2f;</span><br></pre></td></tr></table></figure></p>
<p>该数据类型时opencv中我们最常用的数据类型之一。</p>
<hr>
<h2 id="u4E94_uFF0CRect__uFF0CRotatedRect"><a href="#u4E94_uFF0CRect__uFF0CRotatedRect" class="headerlink" title="五，Rect_，RotatedRect"></a>五，Rect_，RotatedRect</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-2"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-2" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>该类则是点Point和尺寸Size的合体了，代表着一副图像中在某个特定位置的矩形框。它最主要的数据成员就是（x, y, width, height），（x, y）表示矩形框左上顶点的位置，而RotatedRect则代表着一个旋转以后的矩形框，除了和矩形框拥有相同的（x, y, width, height）以外，还多了一个angel（旋转角度）的数据成员：<br><img src="./1450936414855.png" alt="Alt text"></p>
<h3 id="u7C7B_u5B9A_u4E49-3"><a href="#u7C7B_u5B9A_u4E49-3" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Rect_</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! various constructors</span></span><br><span class="line">    Rect_();</span><br><span class="line">    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);</span><br><span class="line">    Rect_(<span class="keyword">const</span> Rect_&amp; r);</span><br><span class="line">    Rect_(<span class="keyword">const</span> CvRect&amp; r);</span><br><span class="line">    Rect_(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; org, <span class="keyword">const</span> Size_&lt;_Tp&gt;&amp; sz);</span><br><span class="line">    Rect_(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt1, <span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt2);</span><br><span class="line"></span><br><span class="line">    Rect_&amp; <span class="keyword">operator</span> = ( <span class="keyword">const</span> Rect_&amp; r );</span><br><span class="line">    <span class="comment">//! the top-left corner</span></span><br><span class="line">    Point_&lt;_Tp&gt; tl() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">//! the bottom-right corner</span></span><br><span class="line">    Point_&lt;_Tp&gt; br() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! size (width, height) of the rectangle</span></span><br><span class="line">    Size_&lt;_Tp&gt; size() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">//! area (width*height) of the rectangle</span></span><br><span class="line">    _<span class="function">Tp <span class="title">area</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion to another data type</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Rect_&lt;_Tp2&gt;() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">//! conversion to the old-style CvRect</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvRect</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! checks whether the rectangle contains the point</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    _Tp x, y, width, height; <span class="comment">//&lt; the top-left corner, as well as width and height of the rectangle</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该模版类预定义了一些类，来供我们使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Rect_&lt;<span class="keyword">int</span>&gt; Rect;</span><br></pre></td></tr></table></figure></p>
<p>该类实例能够进行多种数学运算如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rect</span> = <span class="built_in">rect</span> + <span class="built_in">point</span> (矩形位置平移)</span><br><span class="line"><span class="built_in">rect</span> = <span class="built_in">rect</span> + <span class="built_in">size</span> (扩大或缩小矩形)</span><br><span class="line"><span class="built_in">rect</span> += <span class="built_in">point</span>, <span class="built_in">rect</span> -= <span class="built_in">point</span>, <span class="built_in">rect</span> += <span class="built_in">size</span>, <span class="built_in">rect</span> -= <span class="built_in">size</span> </span><br><span class="line"><span class="built_in">rect</span> = rect1 &amp; rect2</span><br><span class="line"><span class="built_in">rect</span> = rect1 | rect2 </span><br><span class="line"><span class="built_in">rect</span> &amp;= rect1, <span class="built_in">rect</span> |= rect1 </span><br><span class="line"><span class="built_in">rect</span> == rect1, <span class="built_in">rect</span> != rect1</span><br></pre></td></tr></table></figure></p>
<p>该类型是opencv中最常用的数据类型之一。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">CV_EXPORTS</span> <span class="title">RotatedRect</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! various constructors</span></span><br><span class="line">    RotatedRect();</span><br><span class="line">    RotatedRect(<span class="keyword">const</span> Point2f&amp; center, <span class="keyword">const</span> Size2f&amp; size, <span class="keyword">float</span> angle);</span><br><span class="line">    RotatedRect(<span class="keyword">const</span> CvBox2D&amp; box);</span><br><span class="line">    <span class="comment">//! returns 4 vertices of the rectangle</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">points</span>(<span class="params">Point2f pts[]</span>) <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! returns the minimal up-right rectangle containing the rotated rectangle</span></span><br><span class="line">    <span class="function">Rect <span class="title">boundingRect</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! conversion to the old-style CvBox2D structure</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvBox2D</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</span><br><span class="line">    Point2f center; <span class="comment">//&lt; the rectangle mass center</span></span><br><span class="line">    Size2f size;    <span class="comment">//&lt; width and height of the rectangle</span></span><br><span class="line">    <span class="keyword">float</span> angle;    <span class="comment">//&lt; the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>旋转矩形使用范例如下：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Mat image(200, 200, CV_8UC3, Scalar(0))<span class="comment">;</span></span><br><span class="line">RotatedRect rRect = RotatedRect(Point2f(<span class="number">100,100</span>), Size2f(100,50), 30)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Point2f vertices[4]<span class="comment">;</span></span><br><span class="line">rRect.points(vertices)<span class="comment">;</span></span><br><span class="line">for (int i = 0<span class="comment">; i &lt; 4; i++)</span></span><br><span class="line">    line(image, vertices[i], vertices[(i+1)%4], Scalar(<span class="number">0,255,0</span>))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Rect brect = rRect.boundingRect()<span class="comment">;</span></span><br><span class="line">rectangle(image, brect, Scalar(<span class="number">255,0,0</span>))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">imshow("rectangles", image)<span class="comment">;</span></span><br><span class="line">waitKey(0)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="u516D_uFF0CMat_2C_Matx_2C_Mat_2C_SparseMat_2C_SparseMat"><a href="#u516D_uFF0CMat_2C_Matx_2C_Mat_2C_SparseMat_2C_SparseMat" class="headerlink" title="六，Mat, Matx, Mat, SparseMat, SparseMat"></a>六，<code>Mat</code>, Matx, Mat<em>, SparseMat, SparseMat</em></h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-3"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-3" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>矩阵是计算机视觉，计算机图像处理中最终要的概念。由于图像在计算机中都采用像素点来表示，一副图像是由width*height个像素点来组成，这所有的点组合起来就像是数学中的Mat（矩阵）。将矩阵的使用学好了，对于计算机图像处理，计算机视觉的认知就算是真正的开始了。毫无疑问，矩阵（Mat）这种数据类型是opencv最核心的数据类型，没有之一。然而为了应对各种图像的情况，opencv定义了多种类型的矩阵供我们使用。以下便让我一一介绍：</p>
<h3 id="u7C7B_u5B9A_u4E49-4"><a href="#u7C7B_u5B9A_u4E49-4" class="headerlink" title="类定义"></a>类定义</h3><ul>
<li>Mat（矩阵）<br>该矩阵代表着n维数字类型的单通道或者是多通道的数组类型的数据。它可以存储实数或者是复数向量和矩阵，灰度图或者彩色图，立体像素卷，向量域，点云，直方图（高维的直方图最好用稀疏矩阵SparseMat来存储）等等。数组M的数据位置被数组M.step[]定义，所以访问矩阵中的M(i0,i1,···,in-1),就可以通过如下公式访问：<figure class="highlight"><figcaption><span>= M.data + M.step[0]*i_0 + M.step[1]*i_1 + ... + M.step[M.dims-1]*i_&#123;M.dims-1&#125; ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#23545;&#20110;&#20108;&#32500;&#30697;&#38453;&#26469;&#35828;&#65292;&#35775;&#38382;&#20854;&#20013;&#30340;&#20803;&#32032;&#23601;&#26159;&#10;```addr(M_&#123;i,j&#125;) = M.data + M.step[0]*i + M.step[1]*j</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在opencv1.x中与矩阵Mat相对应的数据类型就是CvMat, IplImage, 和CvMatND等,其类定义如下：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class CV_EXPORTS Mat</span><br><span class="line">&#123;<span class="keyword"></span><br><span class="line">public</span>:</span><br><span class="line">    // ... a lot of methods ...</span><br><span class="line"><span class="keyword">    .</span>..</span><br><span class="line"></span><br><span class="line">    /*! includes several bit-fields:</span><br><span class="line">         - the magic signature</span><br><span class="line">         - continuity flag</span><br><span class="line">         - depth</span><br><span class="line">         - number of channels</span><br><span class="line">     */</span><br><span class="line">   <span class="instruction"> int </span>flags;</span><br><span class="line">    //! the<span class="instruction"> array </span>dimensionality, &gt;= 2</span><br><span class="line">   <span class="instruction"> int </span>dims;</span><br><span class="line">    //! the number of rows<span class="instruction"> and </span>columns<span class="instruction"> or </span>(-1, -1<span class="function">)</span> when the<span class="instruction"> array </span>has more than 2 dimensions</span><br><span class="line">   <span class="instruction"> int </span>rows, cols;</span><br><span class="line">    //! pointer to the data</span><br><span class="line">    uchar* data;</span><br><span class="line"></span><br><span class="line">    //! pointer to the reference counter;</span><br><span class="line">    // when<span class="instruction"> array </span>points to user-allocated data, the pointer is NULL</span><br><span class="line">    int* refcount;</span><br><span class="line"></span><br><span class="line">    // other members</span><br><span class="line"><span class="keyword">    .</span>..</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一般情况下表示一副图像只需要二维矩阵就够了，要么一个像素点事灰度值，要么一个像素点是一个向量，存储rgb三色。<br>基本的构造一个Mat对象的方法如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make a 7x7 complex matrix filled with 1+3j.</span></span><br><span class="line"><span class="keyword">Mat</span> <span class="literal">M</span>(7,7,CV_32FC2,<span class="literal">Scalar</span>(1,3));</span><br><span class="line"></span><br><span class="line"><span class="comment">// and now turn M to a 100x60 15-channel 8-bit matrix.</span></span><br><span class="line"><span class="comment">// The old content will be deallocated</span></span><br><span class="line"><span class="keyword">M</span>.create(100,60,CV_8UC(15));</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a 100x100x100 8-bit array</span></span><br><span class="line">int sz[] = &#123;100, 100, 100&#125;;</span><br><span class="line"><span class="keyword">Mat</span> bigCube(3, sz, CV_8U, <span class="keyword">Scalar</span>::all(0));</span><br><span class="line"><span class="comment">// add the 5-th row, multiplied by 3 to the 3rd row</span></span><br><span class="line"><span class="keyword">M</span>.row(3) = <span class="keyword">M</span>.row(3) + <span class="keyword">M</span>.row(5)*3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now copy the 7-th column to the 1-st column</span></span><br><span class="line"><span class="comment">// M.col(1) = M.col(7); // this will not work</span></span><br><span class="line"><span class="keyword">Mat</span> M1 = <span class="keyword">M</span>.col(1);</span><br><span class="line"><span class="keyword">M</span>.col(7).copyTo(M1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new 320x240 image</span></span><br><span class="line"><span class="keyword">Mat</span> img(Size(320,240),CV_8UC3);</span><br><span class="line"><span class="comment">// select a ROI</span></span><br><span class="line"><span class="keyword">Mat</span> roi(img, Rect(10,10,100,100));</span><br><span class="line"><span class="comment">// fill the ROI with (0,255,0) (which is green in RGB space);</span></span><br><span class="line"><span class="comment">// the original 320x240 image will be modified</span></span><br><span class="line">roi = <span class="literal">Scalar</span>(0,255,0);</span><br><span class="line"><span class="keyword">Mat</span> A = <span class="keyword">Mat</span>::eye(10, 10, CV_32S);</span><br><span class="line"><span class="comment">// extracts A columns, 1 (inclusive) to 3 (exclusive).</span></span><br><span class="line"><span class="keyword">Mat</span> B = A(<span class="keyword">Range</span>::all(), <span class="keyword">Range</span>(1, 3));</span><br><span class="line"><span class="comment">// extracts B rows, 5 (inclusive) to 9 (exclusive).</span></span><br><span class="line"><span class="comment">// that is, C ~ A(Range(5, 9), Range(1, 3))</span></span><br><span class="line"><span class="keyword">Mat</span> C = B(<span class="keyword">Range</span>(5, 9), <span class="keyword">Range</span>::all());</span><br><span class="line">Size size; Point ofs;</span><br><span class="line">C.locateROI(size, ofs);</span><br><span class="line"><span class="comment">// size will be (width=10,height=10) and the ofs will be (x=1, y=5)</span></span><br></pre></td></tr></table></figure></p>
<p>Mat的构造函数如下：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">C++: Mat::Mat()</span><br><span class="line">C++: Mat::Mat(int rows, int cols, int type)</span><br><span class="line">C++: Mat::Mat(Size size, int type)</span><br><span class="line">C++: Mat::Mat(int rows, int cols, int type, <span class="keyword">const</span> Scalar&amp; s)</span><br><span class="line">C++: Mat::Mat(Size size, int type, <span class="keyword">const</span> Scalar&amp; s)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> Mat&amp; m)</span><br><span class="line">C++: Mat::Mat(int rows, int cols, int type, void* data, size_t <span class="keyword">step</span>=AUTO_STEP)</span><br><span class="line">C++: Mat::Mat(Size size, int type, void* data, size_t <span class="keyword">step</span>=AUTO_STEP)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> Mat&amp; m, <span class="keyword">const</span> Range&amp; rowRange, <span class="keyword">const</span> Range&amp; colRange=Range::all() )</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> Mat&amp; m, <span class="keyword">const</span> Rect&amp; roi)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> CvMat* m, bool copyData=<span class="literal">false</span>)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> IplImage* img, bool copyData=<span class="literal">false</span>)</span><br><span class="line">C++: template&lt;typename T, int n&gt; <span class="keyword">explicit</span> Mat::Mat(<span class="keyword">const</span> Vec&lt;T, n&gt;&amp; vec, bool copyData=<span class="literal">true</span>)</span><br><span class="line">C++: template&lt;typename T, int m, int n&gt; <span class="keyword">explicit</span> Mat::Mat(<span class="keyword">const</span> Matx&lt;T, m, n&gt;&amp; vec, bool copyData=<span class="literal">true</span>)</span><br><span class="line">C++: template&lt;typename T&gt; <span class="keyword">explicit</span> Mat::Mat(<span class="keyword">const</span> vector&lt;T&gt;&amp; vec, bool copyData=<span class="literal">false</span>)</span><br><span class="line">C++: Mat::Mat(int ndims, <span class="keyword">const</span> int* sizes, int type)</span><br><span class="line">C++: Mat::Mat(int ndims, <span class="keyword">const</span> int* sizes, int type, <span class="keyword">const</span> Scalar&amp; s)</span><br><span class="line">C++: Mat::Mat(int ndims, <span class="keyword">const</span> int* sizes, int type, void* data, <span class="keyword">const</span> size_t* steps=<span class="number">0</span>)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> Mat&amp; m, <span class="keyword">const</span> Range* ranges)</span><br><span class="line">Parameters:	</span><br><span class="line">ndims – Array dimensionality.</span><br><span class="line">rows – Number <span class="keyword">of</span> rows <span class="keyword">in</span> a <span class="number">2</span>D array.</span><br><span class="line">cols – Number <span class="keyword">of</span> columns <span class="keyword">in</span> a <span class="number">2</span>D array.</span><br><span class="line">roi – Region <span class="keyword">of</span> interest.</span><br><span class="line">size – <span class="number">2</span>D array size: Size(cols, rows) . <span class="keyword">In</span> the Size() constructor, the number <span class="keyword">of</span> rows <span class="keyword">and</span> the number <span class="keyword">of</span> columns go <span class="keyword">in</span> the reverse <span class="keyword">order</span>.</span><br><span class="line">sizes – Array <span class="keyword">of</span> integers specifying an n-dimensional array shape.</span><br><span class="line">type – Array type. Use CV_8UC1, ..., CV_64FC4 <span class="keyword">to</span> create <span class="number">1</span>-<span class="number">4</span> channel matrices, <span class="keyword">or</span> CV_8UC(n), ..., CV_64FC(n) <span class="keyword">to</span> create multi-channel (up <span class="keyword">to</span> CV_CN_MAX channels) matrices.</span><br><span class="line">s – An <span class="keyword">optional</span> value <span class="keyword">to</span> initialize <span class="keyword">each</span> matrix element <span class="keyword">with</span>. <span class="keyword">To</span> <span class="keyword">set</span> all the matrix elements <span class="keyword">to</span> the particular value after the construction, use the assignment <span class="keyword">operator</span> Mat::<span class="keyword">operator</span>=(<span class="keyword">const</span> Scalar&amp; value) .</span><br><span class="line">data – Pointer <span class="keyword">to</span> the user data. Matrix constructors that <span class="keyword">take</span> data <span class="keyword">and</span> <span class="keyword">step</span> parameters <span class="keyword">do</span> <span class="keyword">not</span> allocate matrix data. Instead, they just initialize the matrix header that points <span class="keyword">to</span> the specified data, which means that no data <span class="keyword">is</span> copied. This operation <span class="keyword">is</span> very efficient <span class="keyword">and</span> can be used <span class="keyword">to</span> process external data <span class="keyword">using</span> OpenCV functions. The external data <span class="keyword">is</span> <span class="keyword">not</span> automatically deallocated, so you should <span class="keyword">take</span> care <span class="keyword">of</span> it.</span><br><span class="line"><span class="keyword">step</span> – Number <span class="keyword">of</span> bytes <span class="keyword">each</span> matrix row occupies. The value should include the padding bytes at the <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">each</span> row, <span class="keyword">if</span> any. <span class="keyword">If</span> the parameter <span class="keyword">is</span> missing (<span class="keyword">set</span> <span class="keyword">to</span> AUTO_STEP ), no padding <span class="keyword">is</span> assumed <span class="keyword">and</span> the actual <span class="keyword">step</span> <span class="keyword">is</span> calculated <span class="keyword">as</span> cols*elemSize() . See Mat::elemSize() .</span><br><span class="line">steps – Array <span class="keyword">of</span> ndims-<span class="number">1</span> steps <span class="keyword">in</span> <span class="keyword">case</span> <span class="keyword">of</span> a multi-dimensional array (the last <span class="keyword">step</span> <span class="keyword">is</span> always <span class="keyword">set</span> <span class="keyword">to</span> the element size). <span class="keyword">If</span> <span class="keyword">not</span> specified, the matrix <span class="keyword">is</span> assumed <span class="keyword">to</span> be continuous.</span><br><span class="line">m – Array that (<span class="keyword">as</span> a whole <span class="keyword">or</span> partly) <span class="keyword">is</span> assigned <span class="keyword">to</span> the constructed matrix. No data <span class="keyword">is</span> copied <span class="keyword">by</span> these constructors. Instead, the header pointing <span class="keyword">to</span> m data <span class="keyword">or</span> its <span class="keyword">sub</span>-array <span class="keyword">is</span> constructed <span class="keyword">and</span> associated <span class="keyword">with</span> it. The reference counter, <span class="keyword">if</span> any, <span class="keyword">is</span> incremented. So, <span class="keyword">when</span> you modify the matrix formed <span class="keyword">using</span> such a constructor, you also modify the corresponding elements <span class="keyword">of</span> m . <span class="keyword">If</span> you want <span class="keyword">to</span> have an independent copy <span class="keyword">of</span> the <span class="keyword">sub</span>-array, use Mat::clone() .</span><br><span class="line">img – Pointer <span class="keyword">to</span> the old-style IplImage image <span class="keyword">structure</span>. <span class="keyword">By</span> <span class="keyword">default</span>, the data <span class="keyword">is</span> <span class="keyword">shared</span> between the original image <span class="keyword">and</span> the <span class="keyword">new</span> matrix. But <span class="keyword">when</span> copyData <span class="keyword">is</span> <span class="keyword">set</span>, the full copy <span class="keyword">of</span> the image data <span class="keyword">is</span> created.</span><br><span class="line">vec – STL vector whose elements form the matrix. The matrix has a <span class="built_in">single</span> column <span class="keyword">and</span> the number <span class="keyword">of</span> rows equal <span class="keyword">to</span> the number <span class="keyword">of</span> vector elements. Type <span class="keyword">of</span> the matrix matches the type <span class="keyword">of</span> vector elements. The constructor can handle arbitrary types, <span class="keyword">for</span> which there <span class="keyword">is</span> a properly declared DataType . This means that the vector elements must be primitive numbers <span class="keyword">or</span> uni-type numerical tuples <span class="keyword">of</span> numbers. Mixed-type structures are <span class="keyword">not</span> supported. The corresponding constructor <span class="keyword">is</span> <span class="keyword">explicit</span>. Since STL vectors are <span class="keyword">not</span> automatically converted <span class="keyword">to</span> Mat instances, you should write Mat(vec) explicitly. Unless you copy the data <span class="keyword">into</span> the matrix ( copyData=<span class="literal">true</span> ), no <span class="keyword">new</span> elements will be added <span class="keyword">to</span> the vector because it can potentially yield vector data reallocation, <span class="keyword">and</span>, thus, the matrix data pointer will be invalid.</span><br><span class="line">copyData – Flag <span class="keyword">to</span> specify whether the underlying data <span class="keyword">of</span> the STL vector <span class="keyword">or</span> the old-style CvMat <span class="keyword">or</span> IplImage should be copied <span class="keyword">to</span> (<span class="literal">true</span>) <span class="keyword">or</span> <span class="keyword">shared</span> <span class="keyword">with</span> (<span class="literal">false</span>) the newly constructed matrix. <span class="keyword">When</span> the data <span class="keyword">is</span> copied, the allocated buffer <span class="keyword">is</span> managed <span class="keyword">using</span> Mat reference counting mechanism. <span class="keyword">While</span> the data <span class="keyword">is</span> <span class="keyword">shared</span>, the reference counter <span class="keyword">is</span> NULL, <span class="keyword">and</span> you should <span class="keyword">not</span> deallocate the data <span class="keyword">until</span> the matrix <span class="keyword">is</span> <span class="keyword">not</span> destructed.</span><br><span class="line">rowRange – Range <span class="keyword">of</span> the m rows <span class="keyword">to</span> <span class="keyword">take</span>. <span class="keyword">As</span> usual, the range start <span class="keyword">is</span> inclusive <span class="keyword">and</span> the range <span class="keyword">end</span> <span class="keyword">is</span> exclusive. Use Range::all() <span class="keyword">to</span> <span class="keyword">take</span> all the rows.</span><br><span class="line">colRange – Range <span class="keyword">of</span> the m columns <span class="keyword">to</span> <span class="keyword">take</span>. Use Range::all() <span class="keyword">to</span> <span class="keyword">take</span> all the columns.</span><br><span class="line">ranges – Array <span class="keyword">of</span> selected ranges <span class="keyword">of</span> m along <span class="keyword">each</span> dimensionality.</span><br></pre></td></tr></table></figure></p>
<p>Mat的其他各种成员方法见<a href="http://docs.opencv.org/2.4.11/modules/core/doc/basic_structures.html#mat" target="_blank" rel="external">Mat详解</a></p>
<ul>
<li>Matx（小矩阵）<br>该类型的矩阵为能够确定类型，确定尺寸和确定编译时间的小矩阵。<br>其基本定义如下；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">int</span> m, <span class="keyword">int</span> n&gt; <span class="keyword">class</span> Matx &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">1</span>, <span class="number">2</span>&gt; Matx12f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">2</span>&gt; Matx12d;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">1</span>, <span class="number">6</span>&gt; Matx16f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">6</span>&gt; Matx16d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">1</span>&gt; Matx21f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">1</span>&gt; Matx21d;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">6</span>, <span class="number">1</span>&gt; Matx61f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">1</span>&gt; Matx61d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">2</span>&gt; Matx22f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">2</span>&gt; Matx22d;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">6</span>, <span class="number">6</span>&gt; Matx66f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">6</span>&gt; Matx66d;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用范例如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matx33f <span class="title">m</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">          <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">          <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(Mat(m*m.t())) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>Mat_</p>
</li>
<li><p>SparseMat（稀疏矩阵）</p>
</li>
<li><p>SparseMat_</p>
</li>
</ul>
<hr>
<h2 id="u4E03_uFF0CVec_u548CScalar"><a href="#u4E03_uFF0CVec_u548CScalar" class="headerlink" title="七，Vec和Scalar_"></a>七，Vec和Scalar_</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-4"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-4" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>Vec是一个储存短数字类型的向量，相当于Matx的特例。<br>Scalar_是从Vec继承来的4元向量。</p>
<h3 id="u7C7B_u5B9A_u4E49-5"><a href="#u7C7B_u5B9A_u4E49-5" class="headerlink" title="类定义"></a>类定义</h3><p>Vec有许多预定义的类<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">int</span> n&gt; <span class="keyword">class</span> Vec : <span class="keyword">public</span> Matx&lt;_Tp, n, <span class="number">1</span>&gt; &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;uchar, <span class="number">2</span>&gt; Vec2b;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;uchar, <span class="number">3</span>&gt; Vec3b;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;uchar, <span class="number">4</span>&gt; Vec4b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">short</span>, <span class="number">2</span>&gt; Vec2s;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">short</span>, <span class="number">3</span>&gt; Vec3s;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">short</span>, <span class="number">4</span>&gt; Vec4s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt; Vec2i;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; Vec3i;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">int</span>, <span class="number">4</span>&gt; Vec4i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">float</span>, <span class="number">2</span>&gt; Vec2f;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">float</span>, <span class="number">3</span>&gt; Vec3f;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">float</span>, <span class="number">4</span>&gt; Vec4f;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">float</span>, <span class="number">6</span>&gt; Vec6f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">double</span>, <span class="number">2</span>&gt; Vec2d;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">double</span>, <span class="number">3</span>&gt; Vec3d;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">double</span>, <span class="number">4</span>&gt; Vec4d;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">double</span>, <span class="number">6</span>&gt; Vec6d;</span><br></pre></td></tr></table></figure></p>
<p>因为Vec的特殊性质，Vec<t,2>可以和Point<em>互相转换，而Vec<t,3>可以和Point3</t,3></em>互相转换，而Vec<t,4>则可以和CvScalar 或者是Scalar_互相转换，可以使用[]来访问Vec的数据。<br>以下是Vec的一些基本运算：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">v1</span> = <span class="literal">v2</span> + <span class="literal">v3</span></span><br><span class="line"><span class="label">v1</span> = <span class="literal">v2</span> - <span class="literal">v3</span></span><br><span class="line"><span class="label">v1</span> = <span class="literal">v2</span> * scale</span><br><span class="line"><span class="label">v1</span> = scale * <span class="literal">v2</span></span><br><span class="line"><span class="label">v1</span> = -<span class="literal">v2</span></span><br><span class="line"><span class="label">v1</span> += <span class="literal">v2</span> <span class="keyword">and </span>other augmenting operations</span><br><span class="line"><span class="label">v1</span> == <span class="literal">v2</span>, <span class="literal">v1</span> != <span class="literal">v2</span></span><br><span class="line"><span class="label">norm</span>(<span class="literal">v1</span>) (euclidean norm)</span><br></pre></td></tr></table></figure></t,4></t,2></p>
<p>因为Scalar<em>是从Vec<t,4>继承而来，而且Scalar</t,4></em>只能为4元向量。它与opencv1.x的CvScalar相对应，并且二者可以相互转化。Scalar<em>的主要作用是传递像素值。（rgbe）。<br>Scalar</em>的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Scalar_ : <span class="keyword">public</span> Vec&lt;_Tp, <span class="number">4</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! various constructors</span></span><br><span class="line">    Scalar_();</span><br><span class="line">    Scalar_(_Tp v0, _Tp v1, _Tp v2=<span class="number">0</span>, _Tp v3=<span class="number">0</span>);</span><br><span class="line">    Scalar_(<span class="keyword">const</span> CvScalar&amp; s);</span><br><span class="line">    Scalar_(_Tp v0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! returns a scalar with all elements set to v0</span></span><br><span class="line">    <span class="keyword">static</span> Scalar_&lt;_Tp&gt; all(_Tp v0);</span><br><span class="line">    <span class="comment">//! conversion to the old-style CvScalar</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvScalar</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion to another data type</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt; <span class="keyword">operator</span> Scalar_&lt;T2&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! per-element product</span></span><br><span class="line">    Scalar_&lt;_Tp&gt; mul(<span class="keyword">const</span> Scalar_&lt;_Tp&gt;&amp; t, <span class="keyword">double</span> scale=<span class="number">1</span> ) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// returns (v0, -v1, -v2, -v3)</span></span><br><span class="line">    Scalar_&lt;_Tp&gt; conj() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// returns true iff v1 == v2 == v3 == 0</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isReal</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Scalar_&lt;<span class="keyword">double</span>&gt; Scalar;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="u516B_uFF0CRange"><a href="#u516B_uFF0CRange" class="headerlink" title="八，Range"></a>八，Range</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-5"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-5" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>该数据类型顾名思义表示的是一个范围，它的主要数据成员就是start和end，它和opencv1.x中的CvSlice相对应<br>，这个类的主要作用就相当于matlab矩阵中的：运算符，可以访问矩阵中的行或者列的范围。</p>
<h3 id="u7C7B_u5B9A_u4E49-6"><a href="#u7C7B_u5B9A_u4E49-6" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CV_EXPORTS</span> <span class="title">Range</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Range();</span><br><span class="line">    Range(<span class="keyword">int</span> _start, <span class="keyword">int</span> _end);</span><br><span class="line">    Range(<span class="keyword">const</span> CvSlice&amp; slice);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Range <span class="title">all</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvSlice</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="u4E5D_uFF0CPtr"><a href="#u4E5D_uFF0CPtr" class="headerlink" title="九，Ptr"></a>九，Ptr</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-6"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-6" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>在opencv2.x介绍中，已经说明opencv具有自动内存管理的功能。其实现自动内存管理功能的最主要的方式就是通过Ptr这个指针类来实现的，它相当于c++中的shared_ptr,具有引用计数的功能，当没有任何变量引用一块内存区域时，Ptr就会自动释放这块内存区域。</p>
<h3 id="u7C7B_u5B9A_u4E49-7"><a href="#u7C7B_u5B9A_u4E49-7" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> Ptr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// default constructor</span></span><br><span class="line">    Ptr();</span><br><span class="line">    <span class="comment">// constructor that wraps the object pointer</span></span><br><span class="line">    Ptr(_Tp* _obj);</span><br><span class="line">    <span class="comment">// destructor: calls release()</span></span><br><span class="line">    ~Ptr();</span><br><span class="line">    <span class="comment">// copy constructor; increments ptr's reference counter</span></span><br><span class="line">    Ptr(<span class="keyword">const</span> Ptr&amp; ptr);</span><br><span class="line">    <span class="comment">// assignment operator; decrements own reference counter</span></span><br><span class="line">    <span class="comment">// (with release()) and increments ptr's reference counter</span></span><br><span class="line">    Ptr&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Ptr&amp; ptr);</span><br><span class="line">    <span class="comment">// increments reference counter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addref</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// decrements reference counter; when it becomes 0,</span></span><br><span class="line">    <span class="comment">// delete_obj() is called</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// user-specified custom object deletion operation.</span></span><br><span class="line">    <span class="comment">// by default, "delete obj;" is called</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete_obj</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// returns true if obj == 0;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provide access to the object fields and methods</span></span><br><span class="line">    _Tp* <span class="keyword">operator</span> -&gt; ();</span><br><span class="line">    <span class="keyword">const</span> _Tp* <span class="keyword">operator</span> -&gt; () <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the underlying object pointer;</span></span><br><span class="line">    <span class="comment">// thanks to the methods, the Ptr&lt;_Tp&gt; can be</span></span><br><span class="line">    <span class="comment">// used instead of _Tp*</span></span><br><span class="line">    <span class="keyword">operator</span> _Tp* ();</span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">const</span> _Tp*() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// the encapsulated object pointer</span></span><br><span class="line">    _Tp* obj;</span><br><span class="line">    <span class="comment">// the associated reference counter</span></span><br><span class="line">    <span class="keyword">int</span>* refcount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过使用Ptr &lt; T &gt; obj = new T()来声明一个变量，就会由Ptr来自动管理内存分配和释放。 </p>
<hr>
<h2 id="u5341_uFF0CInputArray_u548COutputArray"><a href="#u5341_uFF0CInputArray_u548COutputArray" class="headerlink" title="十，InputArray和OutputArray"></a>十，InputArray和OutputArray</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-7"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-7" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>InputArray是用来在opencv函数中用来传递只读参数的代理类。<code>typedef const _InputArray&amp; InputArray;</code>，_InputArray是一个可以通过Mat，Mat__&lt; T &gt;，Matx<t,m,n>,std::vector&lt; T &gt;,std::vector<std::vector< t="">&gt;或者std::vector&lt; Mat &gt;等数组类型的类来构造，所以当opencv函数中传递参数的数据类型不明确时，可以通过InputArray来作为代理。<br>例：<br>函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myAffineTransform</span><span class="params">(InputArray _src, OutputArray _dst, InputArray _m)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// get Mat headers for input arrays. This is O(1) operation,</span></span><br><span class="line">    <span class="comment">// unless _src and/or _m are matrix expressions.</span></span><br><span class="line">    Mat src = _src.getMat(), m = _m.getMat();</span><br><span class="line">    CV_Assert( src.type() == CV_32FC2 &amp;&amp; m.type() == CV_32F &amp;&amp; m.size() == Size(<span class="number">3</span>, <span class="number">2</span>) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [re]create the output array so that it has the proper size and type.</span></span><br><span class="line">    <span class="comment">// In case of Mat it calls Mat::create, in case of STL vector it calls vector::resize.</span></span><br><span class="line">    _dst.create(src.size(), src.type());</span><br><span class="line">    Mat dst = _dst.getMat();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.rows; i++ )</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.cols; j++ )</span><br><span class="line">        &#123;</span><br><span class="line">            Point2f pt = src.at&lt;Point2f&gt;(i, j);</span><br><span class="line">            dst.at&lt;Point2f&gt;(i, j) = Point2f(m.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>)*pt.x +</span><br><span class="line">                                            m.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>)*pt.y +</span><br><span class="line">                                            m.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">                                            m.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>)*pt.x +</span><br><span class="line">                                            m.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">1</span>)*pt.y +</span><br><span class="line">                                            m.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></std::vector<></t,m,n></p>
<p>当你使用这个函数时，可以将Mat，Mat__&lt; T &gt;，Matx<t,m,n>,std::vector&lt; T &gt;,std::vector<std::vector< t="">&gt;或者std::vector&lt; Mat &gt;中的任意一个数据类型传递进去。这个特性与c++中的多态特性有些类似。<br>而OutputArray是从InputArray继承而来的。它的功能与InputArray类似。<br>这两个数据类型都有一个共同的限制就是：不要为这两个类显示的构造实例对象。简单来说，他们应该只出现在函数的形参声明中。</std::vector<></t,m,n></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-21T02:17:40.000Z"><a href="/2015/12/21/一，opencv2.x介绍/">2015-12-21</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/21/一，opencv2.x介绍/">opencv2.x介绍</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="u4E00_uFF0Copencv_u6982_u89C8"><a href="#u4E00_uFF0Copencv_u6982_u89C8" class="headerlink" title="一，opencv概览"></a>一，opencv概览</h2><p>opencv（open source computer vision library：<a href="http://opencv.org" target="_blank" rel="external">opencv官网</a>是一个开源的计算机视觉库，该库包含了几百个计算机视觉处理算法。opencv库现阶段已经更新到3.x版本，但由于其不稳定性，故多采用opencv2.x版本。opencv1.x版本是基于c语言撰写的API，而opencv2.x是基于c++撰写的API。<br>opencv采用模块结构，这代表着该库包含了一些分享的或者是静态的库。下面就是各个主要模块的介绍：</p>
<ul>
<li>core-核心模块，该模块定义了opencv里面的基本的数据结构，包含了多维数组Mat和一些被其他模块使用的基本函数。</li>
<li>imgproc-一个图像处理模块，该模块包含了线性和非线性的图像处理滤波器，几何图像转换（缩放，仿射变换，视图弯曲，映射），彩色空间变换，直方图等等。</li>
<li>video-视频分析模块，该模块包含运动估计，背景去除和目标追踪算法。</li>
<li>calib3d-3d校准模块，该模块包含基本的多视图几何算法，单一和立体摄像机校准，目标姿势估计，立体一致性算法和3d重建元素等。</li>
<li>features2d-2d特征模块，改模块包含了显著特征检测器，描述符和描述符匹配器。</li>
<li>objdetect-目标检测模块，该模块包含了目标检测和预定义类的实例（例如faces，eyes，mugs，people，cars等等）。</li>
<li>highgui-该模块包含了一些处理视频捕获，图像和视频编码，以及一些简单的用户界面能力的易于使用的接口。</li>
<li>gpu-该模块包含了为不同的opencv模块使用的GPU加速算法。</li>
<li>其他-其他一些模块为帮助模块，例如FLANN和Google测试包装器，Python绑定等等。</li>
</ul>
<hr>
<h2 id="u4E8C_uFF0Copencv_API_u7279_u6027_u7B80_u4ECB"><a href="#u4E8C_uFF0Copencv_API_u7279_u6027_u7B80_u4ECB" class="headerlink" title="二，opencv API特性简介"></a>二，opencv API特性简介</h2><ul>
<li><p><code>cv命名空间</code><br> 所有的opencv类和函数都被放在cv namespace内了。<br> 访问opencv示例：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"opencv2/core/core.hpp"</span></span></span><br><span class="line">...</span><br><span class="line">cv::Mat H = cv::findHomography(points1, points2, CV_RANSAC, <span class="number">5</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p> 或者</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"opencv2/core/core.hpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line">...</span><br><span class="line">Mat H = findHomography(points1, points2, CV_RANSAC, <span class="number">5</span> );</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p> 一些现有的或者是未来的opencv外部命名可能会与STL或者其他库中的命名冲突，所有最好显示的使用opencv命名空间来解决冲突问题。 </p>
</li>
<li><p><code>自动内存管理</code><br> opencv自动处理所有的内存问题。<br> 首先，std::vector, Mat和其他的数据结构都有析构函数来解除已经分配出去的内存区域。但对于cv::Mat来说，这并不意味着析构函数并总是解除内存分配，因为opencv将数据共享考虑在内了。一个析构器将会减少与Mat数据内存相关的引用指针数量，当引用数量降到0时意味着没有变量再使用这块内存，从而这块内存会被释放。相似的，当一个Mat实例被复制的时候，其实并没有真的开辟一块新的内存空间来存储数据，而是引用数量＋1，而该引用是这个数据块的另一个拥有者。但是可以使用Mat::clone（）函数来创造一个新的内存区域存储数据。<br> 如下代码会帮助你更好的理解其中的内涵：</p>
 <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a big 8Mb matrix</span></span><br><span class="line"><span class="keyword">Mat</span> A(1000, 1000, CV_64F);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create another header for the same matrix;</span></span><br><span class="line"><span class="comment">// this is an instant operation, regardless of the matrix size.</span></span><br><span class="line"><span class="keyword">Mat</span> B = A;</span><br><span class="line"><span class="comment">// create another header for the 3-rd row of A; no data is copied either</span></span><br><span class="line"><span class="keyword">Mat</span> C = B.row(3);</span><br><span class="line"><span class="comment">// now create a separate copy of the matrix</span></span><br><span class="line"><span class="keyword">Mat</span> <span class="keyword">D</span> = B.clone();</span><br><span class="line"><span class="comment">// copy the 5-th row of B to C, that is, copy the 5-th row of A</span></span><br><span class="line"><span class="comment">// to the 3-rd row of A.</span></span><br><span class="line">B.row(5).copyTo(C);</span><br><span class="line"><span class="comment">// now let A and D share the data; after that the modified version</span></span><br><span class="line"><span class="comment">// of A is still referenced by B and C.</span></span><br><span class="line">A = <span class="keyword">D</span>;</span><br><span class="line"><span class="comment">// now make B an empty matrix (which references no memory buffers),</span></span><br><span class="line"><span class="comment">// but the modified version of A will still be referenced by C,</span></span><br><span class="line"><span class="comment">// despite that C is just a single row of the original A</span></span><br><span class="line">B.release();</span><br><span class="line"></span><br><span class="line"><span class="comment">// finally, make a full copy of C. As a result, the big modified</span></span><br><span class="line"><span class="comment">// matrix will be deallocated, since it is not referenced by anyone</span></span><br><span class="line">C = C.clone();</span><br></pre></td></tr></table></figure>
<p> 因此，使用Mat和其他一些基础的数据结构是非常容易的。但是还有其他一些高水平数据或者是用户自定义的数据类型（没有自动内存管理功能）呢？opencv为此提供了Ptr&lt;&gt;这个模板类来解决问题，该类与std::shared_ptr类似。<br> 所以在使用其他数据类型时：不用T* ptr = new T(…); 而是使用Ptr<t> ptr = new T(…);<br> 详情请看<a href="http://docs.opencv.org/2.4.11/modules/core/doc/basic_structures.html#Ptr" target="_blank" rel="external">Ptr&lt;&gt;</a>解析</t></p>
</li>
<li><p><code>输出数据的自动内存分配</code><br> opencv自动解除内存分配，同样在大多数时候也会自动为输出函数参数自动分配内存。因此如果一个函数拥有一个或者多个输入数组（cv::Mat instances） 和一些输出数组，输出数组会自动的分配或者重新分配内存。输出数组的大小和类型都由输入数组的大小和类型决定。如果需要的话，函数还会采用额外的参数来帮助计算输出数组的性质。如以下例子：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"cv.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"highgui.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!cap.isOpened()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Mat frame, edges;</span><br><span class="line">    namedWindow(<span class="string">"edges"</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        cap &gt;&gt; frame;</span><br><span class="line">        cvtColor(frame, edges, CV_BGR2GRAY);</span><br><span class="line">        GaussianBlur(edges, edges, Size(<span class="number">7</span>,<span class="number">7</span>), <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line">        Canny(edges, edges, <span class="number">0</span>, <span class="number">30</span>, <span class="number">3</span>);</span><br><span class="line">        imshow(<span class="string">"edges"</span>, edges);</span><br><span class="line">        <span class="keyword">if</span>(waitKey(<span class="number">30</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其中数组frame是由&gt;&gt;操作符自动分配内存的。因为对于视频捕获模块来说视频frame的分辨率和位深度都是未知的。数组edges是由cvtColor函数自动分配内存的。edges和输入数组frame有相同的大小和位深度。而因为彩色变换码CV_BGR2GRAY被传递到函数中所以edges的通道数为1。同时应该注意到frame和edges只有在循环中的第一次执行时才被分配内存，因为从此以后的所有视频frame都有相同的分辨率。如果你改变了视频分辨率，那数组frame则会再次自动重新分配内存。<br> 这个技术的关键部分就是Mat::create 函数，该函数将需要的数组大小和类型都利用了，如果数组已经有了特定的大小和类型，该方法什么都不会做。相反，他会释放已经分配的内存然后重新分配一块要求大小的新的内存。大多数的函数都会为输出数组调用Mat::create方法，然后就实现了为输出数组自动分配内存。<br> 来自于这个方案的一些值得注意的异常就是cv::minChannels, cv::RNG::fill以及一些其他的函数和方法。他们并不能为输出数组自动分配内存，所以你必须自己提前完成这个工作。</p>
</li>
<li><code>饱和算法</code><br> opencv作为一个计算机视觉库，它经常处理一些图像像素，这些像素常被编码为每通道8或者16比特因此他们得数值范围有限制。例如对图像进行特性操作，如彩色空间变换，亮度加强，对齐，锐化以及复杂的插值操作都会产生超出允许范围的数值。如果你仅仅用最低的8位或者16位来存储结果，这些结果可能会影响进一步的图像分析。为了解决这个问题，被称作饱和算法的东西就出现了。例如，为了存储r（一个操作的结果数据）到8位深度的图像里，你发现在0~255内最近的值：<br> I(x,y)= min ( max (round(r), 0), 255);<br> 相似的法则被应用到有符号8位，有符号16位以及无符号数据类型中了。这种语义在opencv库中到处都有使用。在c++中，会采用saturate_cast&lt;&gt;函数（类似于标准c++的转换操作），如以下例子：<br> I.at<uchar>(y, x) = saturate_cast<uchar>(r);<br> cv::uchar是opencv的8位无符号整型数据类型。<br> 注意：饱和算法并不会作用于32位的整型结果。</uchar></uchar></li>
<li><code>固定像素类型，模板的限制使用</code><br> 模板是c++的一个重大特性，该特性提供了非常强有力的高效的而且安全的数据结构和算法的实现。然而，模板的扩展使可能会增加编译时间和代码量。除此之外，当模板被独立使用的时候接口和实现将会很难分离。对于基本的算法来说这样很好，但是对于一个算法可能包含几千行代码的计算机视觉库来说这样并不友好。为了简化与其他语言（如Python，java，matlab这些可能没有模板或只有有限的模板能力的语言）的绑定发展，现今的opencv实现是基于多态和运行时分配而非模板。在那些运行时分配可能会很慢的地方（如像素访问运算符），或者不可能（如通用的Ptr&lt;&gt;的实现）或者非常不方便（如saturate_cast&lt;&gt;）现在的实现介绍了一些小型的模板类，方法和函数。而opencv中任何其他地方使用模板都是收到限制的。<br> 因此，只有有限的固定的原始数据类型可以被opencv库操作。如下：<ul>
<li>8-bit unsigned integer (uchar)</li>
<li>8-bit signed integer (schar)</li>
<li>8-bit signed integer (schar)</li>
<li>16-bit signed integer (short)</li>
<li>32-bit signed integer (int)</li>
<li>32-bit floating-point number (float)</li>
<li>64-bit floating-point number (double)</li>
<li>一些元素（像素点）包含多个相同数据类型的元素被称为多通道数组，与单通道数组相对应。opencv中最大的可能的通道数被CV_CN_MAX常量设置为512.<br>对于这些基本类型，会应用以下枚举常量：<br>enum { CV_8U=0, CV_8S=1, CV_16U=2, CV_16S=3, CV_32S=4, CV_32F=5, CV_64F=6 };<br>而多通道类型可以用以下选择方式决定：</li>
<li>CV_8UC1 … CV_64FC4 常量(通道数为1-4)</li>
<li>CV_8UC(n) … CV_64FC(n) or CV_MAKETYPE(CV_8U, n) … CV_MAKETYPE(CV_64F, n) 宏，当通道数超过4或者在编译时无法确定<br>范例：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mat <span class="function">mtx</span>(3, 3, CV_32F); <span class="comment">// make a 3x3 floating-point matrix</span></span><br><span class="line">Mat <span class="function">cmtx</span>(10, 1, CV_64FC2); <span class="comment">// make a 10x1 2-channel floating-point</span></span><br><span class="line">                           <span class="comment">// matrix (10-element complex vector)</span></span><br><span class="line">Mat <span class="function">img</span>(<span class="function">Size</span>(1920, 1080), CV_8UC3); <span class="comment">// make a 3-channel (color) image</span></span><br><span class="line">                                    <span class="comment">// of 1920 columns and 1080 rows.</span></span><br><span class="line">Mat <span class="function">grayscale</span>(image<span class="class">.size</span>(), <span class="function">CV_MAKETYPE</span>(image<span class="class">.depth</span>(), 1)); <span class="comment">// make a 1-channel image of</span></span><br><span class="line">                                                            <span class="comment">// the same size and same</span></span><br><span class="line">                                                            <span class="comment">// channel type as img</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>而拥有更复杂元素的数组是无法被opencv库构造和处理的。另外，每个函数和方法都只能够处理所有可能的数组类型中的一部分。通常情况下算法越复杂，能够支持的数据格式越少。<br>以下是一些典型的例子：</p>
<pre><code>* 人脸检测算法只能处理8位的灰度图或者彩色图
* 线性代数函数和大多数的机器学习算法都只能处理浮点类型的数组。
* 基本的函数如cv::add，支持所有的数据类型
* 彩色空间转换函数支持8位无符号整数，16位无符号整数和32位浮点类型。
</code></pre><p>每个函数的支持类型的子集都已经从实践需要中预定义了，而且可能在未来因为新的需要而扩展。</p>
<ul>
<li><code>输入数组和输出数组</code><br> 许多opencv的函数处理2维和多维的数字数组。通常，一些函数采用cpp::class:Mat 作为参数，但是在一些情况下，使用std::vector(例如一个指针集合) 或者Matx&lt;&gt;（例如一个3*3矩阵）是更方便的。为了避免API中的过多的复制，特殊的“代理proxy”类便出现了。最基本的“代理”类是InputArray，在一个函数输入中，他被用于传递只读数组，从InputArrray派生出来的OutputArray类被用于为一个函数确定一个输出数组。通常，你不需要关注其内在类型，它将会自动工作。你可以假设不是使用InputArray和OutputArray，而是使用Mat, std::vector&lt;&gt;, Matx&lt;&gt;, 或者是标量。当一个函数有可选的输入或者输出数组时，你没有该数组，可以传递cv::noArray()。</li>
<li><p><code>错误处理</code><br> opencv使用exceptions来标识重要的错误。当输入数据有一个正确的格式而且属于特定的值范围，但是因为某些原因（如最优化算法没有收敛）算法不能成功执行，它会返回一个特殊的错误码（典型情况是一个boolean值）。<br> exceptions可以是cv::Exception 类或者是它的派生类，而cv::Exception 是std::Exception的派生类。所以它可以在代码中使用标准c++库中的部分优雅的处理。<br> exception 是典型的使用CV_Error(errcode, description)宏，或者它的CV<em>Error</em>(errcode, printf-spec, (printf-args)),或者CV_Assert(condition)宏。对于性能至关重要的代码，使用CV_DbgAssert(condition)。因为自动内存分配，为了防止突然间的错误所有的内部的内存区都是自动解除分配：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// call OpenCV</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( cv::Exception&amp; e )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* err_msg = e.what();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"exception caught: "</span> &lt;&lt; err_msg &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>多线程</code><br> 当前opencv的实现是 re-enterable  ，就是说，相同的函数，一个类实例的相同的常量方法，或者不同的类的相同的非常量方法都可以在不同的线程中被调用。相同的cv::Mat可以在不同的线程中被使用，因为引用计数操作使用了the architecture-specific atomic instructions.</p>
</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-16T13:06:24.540Z"><a href="/2015/12/16/hello-world/">2015-12-16</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/16/hello-world/">Hello World</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/opencv2-x-学习笔记/">opencv2.x 学习笔记</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 kongsicong
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>