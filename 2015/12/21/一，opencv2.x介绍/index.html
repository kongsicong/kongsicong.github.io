<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>一，opencv2.x介绍 | 孔小葱的博客</title>
  <meta name="author" content="kongsicong">
  
  <meta name="description" content="一，opencv概览opencv（open source computer vision library：opencv官网是一个开源的计算机视觉库，该库包含了几百个计算机视觉处理算法。opencv库现阶段已经更新到3.x版本，但由于其不稳定性，故多采用opencv2.x版本。opencv1.x版本是基于c语言撰写的API，而opencv2.x是基于c++撰写的API。opencv采用模块结构，这代表着该库包含了一些分享的或者是静态的库。下面就是各个主要模块的介绍：

core-核心模块，该模块定义了opencv里面的基本的数据结构，包含了多维数组Mat和一些被其他模块使用的基本函数。
imgproc-一个图像处理模块，该模块包含了线性和非线性的图像处理滤波器，几何图像转换（缩放，仿射变换，视图弯曲，映射），彩色空间变换，直方图等等。
video-视频分析模块，该模块包含运动估计，背景去除和目标追踪算法。
calib3d-3d校准模块，该模块包含基本的多视图几何算法，单一和立体摄像机校准，目标姿势估计，立体一致性算法和3d重建元素等。
features2d-2d特征模块，改模块包含了显著特征检测器，描述符和描述符匹配器。
objdetect-目标检测模块，该模块包含了目标检测和预定义类的实例（例如faces，eyes，mugs，people，cars等等）。
highgui-该模块包含了一些处理视频捕获，图像和视频编码，以及一些简单的用户界面能力的易于使用的接口。
gpu-该模块包含了为不同的opencv模块使用的GPU加速算法。
其他-其他一些模块为帮助模块，例如FLANN和Google测试包装器，Python绑定等等。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="一，opencv2.x介绍"/>
  <meta property="og:site_name" content="孔小葱的博客"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="孔小葱的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">孔小葱的博客</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">存档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-21T02:17:40.000Z"><a href="/2015/12/21/一，opencv2.x介绍/">2015-12-21</a></time>
      
      
  
    <h1 class="title">一，opencv2.x介绍</h1>
  

    </header>
    <div class="entry">
      
        <h2 id="u4E00_uFF0Copencv_u6982_u89C8"><a href="#u4E00_uFF0Copencv_u6982_u89C8" class="headerlink" title="一，opencv概览"></a>一，opencv概览</h2><p>opencv（open source computer vision library：<a href="http://opencv.org" target="_blank" rel="external">opencv官网</a>是一个开源的计算机视觉库，该库包含了几百个计算机视觉处理算法。opencv库现阶段已经更新到3.x版本，但由于其不稳定性，故多采用opencv2.x版本。opencv1.x版本是基于c语言撰写的API，而opencv2.x是基于c++撰写的API。<br>opencv采用模块结构，这代表着该库包含了一些分享的或者是静态的库。下面就是各个主要模块的介绍：</p>
<ul>
<li>core-核心模块，该模块定义了opencv里面的基本的数据结构，包含了多维数组Mat和一些被其他模块使用的基本函数。</li>
<li>imgproc-一个图像处理模块，该模块包含了线性和非线性的图像处理滤波器，几何图像转换（缩放，仿射变换，视图弯曲，映射），彩色空间变换，直方图等等。</li>
<li>video-视频分析模块，该模块包含运动估计，背景去除和目标追踪算法。</li>
<li>calib3d-3d校准模块，该模块包含基本的多视图几何算法，单一和立体摄像机校准，目标姿势估计，立体一致性算法和3d重建元素等。</li>
<li>features2d-2d特征模块，改模块包含了显著特征检测器，描述符和描述符匹配器。</li>
<li>objdetect-目标检测模块，该模块包含了目标检测和预定义类的实例（例如faces，eyes，mugs，people，cars等等）。</li>
<li>highgui-该模块包含了一些处理视频捕获，图像和视频编码，以及一些简单的用户界面能力的易于使用的接口。</li>
<li>gpu-该模块包含了为不同的opencv模块使用的GPU加速算法。</li>
<li>其他-其他一些模块为帮助模块，例如FLANN和Google测试包装器，Python绑定等等。</li>
</ul>
<h2 id="3C_21-more-_3E"><a href="#3C_21-more-_3E" class="headerlink" title="<a id=" more"=""></a>"><!--more--></h2><h2 id="u4E8C_uFF0Copencv_API_u7279_u6027_u7B80_u4ECB"><a href="#u4E8C_uFF0Copencv_API_u7279_u6027_u7B80_u4ECB" class="headerlink" title="二，opencv API特性简介"></a>二，opencv API特性简介</h2><ul>
<li><p><code>cv命名空间</code><br> 所有的opencv类和函数都被放在cv namespace内了。<br> 访问opencv示例：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"opencv2/core/core.hpp"</span></span></span><br><span class="line">...</span><br><span class="line">cv::Mat H = cv::findHomography(points1, points2, CV_RANSAC, <span class="number">5</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p> 或者</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"opencv2/core/core.hpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line">...</span><br><span class="line">Mat H = findHomography(points1, points2, CV_RANSAC, <span class="number">5</span> );</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p> 一些现有的或者是未来的opencv外部命名可能会与STL或者其他库中的命名冲突，所有最好显示的使用opencv命名空间来解决冲突问题。 </p>
</li>
<li><p><code>自动内存管理</code><br> opencv自动处理所有的内存问题。<br> 首先，std::vector, Mat和其他的数据结构都有析构函数来解除已经分配出去的内存区域。但对于cv::Mat来说，这并不意味着析构函数并总是解除内存分配，因为opencv将数据共享考虑在内了。一个析构器将会减少与Mat数据内存相关的引用指针数量，当引用数量降到0时意味着没有变量再使用这块内存，从而这块内存会被释放。相似的，当一个Mat实例被复制的时候，其实并没有真的开辟一块新的内存空间来存储数据，而是引用数量＋1，而该引用是这个数据块的另一个拥有者。但是可以使用Mat::clone（）函数来创造一个新的内存区域存储数据。<br> 如下代码会帮助你更好的理解其中的内涵：</p>
 <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a big 8Mb matrix</span></span><br><span class="line"><span class="keyword">Mat</span> A(1000, 1000, CV_64F);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create another header for the same matrix;</span></span><br><span class="line"><span class="comment">// this is an instant operation, regardless of the matrix size.</span></span><br><span class="line"><span class="keyword">Mat</span> B = A;</span><br><span class="line"><span class="comment">// create another header for the 3-rd row of A; no data is copied either</span></span><br><span class="line"><span class="keyword">Mat</span> C = B.row(3);</span><br><span class="line"><span class="comment">// now create a separate copy of the matrix</span></span><br><span class="line"><span class="keyword">Mat</span> <span class="keyword">D</span> = B.clone();</span><br><span class="line"><span class="comment">// copy the 5-th row of B to C, that is, copy the 5-th row of A</span></span><br><span class="line"><span class="comment">// to the 3-rd row of A.</span></span><br><span class="line">B.row(5).copyTo(C);</span><br><span class="line"><span class="comment">// now let A and D share the data; after that the modified version</span></span><br><span class="line"><span class="comment">// of A is still referenced by B and C.</span></span><br><span class="line">A = <span class="keyword">D</span>;</span><br><span class="line"><span class="comment">// now make B an empty matrix (which references no memory buffers),</span></span><br><span class="line"><span class="comment">// but the modified version of A will still be referenced by C,</span></span><br><span class="line"><span class="comment">// despite that C is just a single row of the original A</span></span><br><span class="line">B.release();</span><br><span class="line"></span><br><span class="line"><span class="comment">// finally, make a full copy of C. As a result, the big modified</span></span><br><span class="line"><span class="comment">// matrix will be deallocated, since it is not referenced by anyone</span></span><br><span class="line">C = C.clone();</span><br></pre></td></tr></table></figure>
<p> 因此，使用Mat和其他一些基础的数据结构是非常容易的。但是还有其他一些高水平数据或者是用户自定义的数据类型（没有自动内存管理功能）呢？opencv为此提供了Ptr&lt;&gt;这个模板类来解决问题，该类与std::shared_ptr类似。<br> 所以在使用其他数据类型时：不用T* ptr = new T(…); 而是使用Ptr<t> ptr = new T(…);<br> 详情请看<a href="http://docs.opencv.org/2.4.11/modules/core/doc/basic_structures.html#Ptr" target="_blank" rel="external">Ptr&lt;&gt;</a>解析</t></p>
</li>
<li><p><code>输出数据的自动内存分配</code><br> opencv自动解除内存分配，同样在大多数时候也会自动为输出函数参数自动分配内存。因此如果一个函数拥有一个或者多个输入数组（cv::Mat instances） 和一些输出数组，输出数组会自动的分配或者重新分配内存。输出数组的大小和类型都由输入数组的大小和类型决定。如果需要的话，函数还会采用额外的参数来帮助计算输出数组的性质。如以下例子：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"cv.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"highgui.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!cap.isOpened()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Mat frame, edges;</span><br><span class="line">    namedWindow(<span class="string">"edges"</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        cap &gt;&gt; frame;</span><br><span class="line">        cvtColor(frame, edges, CV_BGR2GRAY);</span><br><span class="line">        GaussianBlur(edges, edges, Size(<span class="number">7</span>,<span class="number">7</span>), <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line">        Canny(edges, edges, <span class="number">0</span>, <span class="number">30</span>, <span class="number">3</span>);</span><br><span class="line">        imshow(<span class="string">"edges"</span>, edges);</span><br><span class="line">        <span class="keyword">if</span>(waitKey(<span class="number">30</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其中数组frame是由&gt;&gt;操作符自动分配内存的。因为对于视频捕获模块来说视频frame的分辨率和位深度都是未知的。数组edges是由cvtColor函数自动分配内存的。edges和输入数组frame有相同的大小和位深度。而因为彩色变换码CV_BGR2GRAY被传递到函数中所以edges的通道数为1。同时应该注意到frame和edges只有在循环中的第一次执行时才被分配内存，因为从此以后的所有视频frame都有相同的分辨率。如果你改变了视频分辨率，那数组frame则会再次自动重新分配内存。<br> 这个技术的关键部分就是Mat::create 函数，该函数将需要的数组大小和类型都利用了，如果数组已经有了特定的大小和类型，该方法什么都不会做。相反，他会释放已经分配的内存然后重新分配一块要求大小的新的内存。大多数的函数都会为输出数组调用Mat::create方法，然后就实现了为输出数组自动分配内存。<br> 来自于这个方案的一些值得注意的异常就是cv::minChannels, cv::RNG::fill以及一些其他的函数和方法。他们并不能为输出数组自动分配内存，所以你必须自己提前完成这个工作。</p>
</li>
<li><code>饱和算法</code><br> opencv作为一个计算机视觉库，它经常处理一些图像像素，这些像素常被编码为每通道8或者16比特因此他们得数值范围有限制。例如对图像进行特性操作，如彩色空间变换，亮度加强，对齐，锐化以及复杂的插值操作都会产生超出允许范围的数值。如果你仅仅用最低的8位或者16位来存储结果，这些结果可能会影响进一步的图像分析。为了解决这个问题，被称作饱和算法的东西就出现了。例如，为了存储r（一个操作的结果数据）到8位深度的图像里，你发现在0~255内最近的值：<br> I(x,y)= min ( max (round(r), 0), 255);<br> 相似的法则被应用到有符号8位，有符号16位以及无符号数据类型中了。这种语义在opencv库中到处都有使用。在c++中，会采用saturate_cast&lt;&gt;函数（类似于标准c++的转换操作），如以下例子：<br> I.at<uchar>(y, x) = saturate_cast<uchar>(r);<br> cv::uchar是opencv的8位无符号整型数据类型。<br> 注意：饱和算法并不会作用于32位的整型结果。</uchar></uchar></li>
<li><code>固定像素类型，模板的限制使用</code><br> 模板是c++的一个重大特性，该特性提供了非常强有力的高效的而且安全的数据结构和算法的实现。然而，模板的扩展使可能会增加编译时间和代码量。除此之外，当模板被独立使用的时候接口和实现将会很难分离。对于基本的算法来说这样很好，但是对于一个算法可能包含几千行代码的计算机视觉库来说这样并不友好。为了简化与其他语言（如Python，java，matlab这些可能没有模板或只有有限的模板能力的语言）的绑定发展，现今的opencv实现是基于多态和运行时分配而非模板。在那些运行时分配可能会很慢的地方（如像素访问运算符），或者不可能（如通用的Ptr&lt;&gt;的实现）或者非常不方便（如saturate_cast&lt;&gt;）现在的实现介绍了一些小型的模板类，方法和函数。而opencv中任何其他地方使用模板都是收到限制的。<br> 因此，只有有限的固定的原始数据类型可以被opencv库操作。如下：<ul>
<li>8-bit unsigned integer (uchar)</li>
<li>8-bit signed integer (schar)</li>
<li>8-bit signed integer (schar)</li>
<li>16-bit signed integer (short)</li>
<li>32-bit signed integer (int)</li>
<li>32-bit floating-point number (float)</li>
<li>64-bit floating-point number (double)</li>
<li>一些元素（像素点）包含多个相同数据类型的元素被称为多通道数组，与单通道数组相对应。opencv中最大的可能的通道数被CV_CN_MAX常量设置为512.<br>对于这些基本类型，会应用以下枚举常量：<br>enum { CV_8U=0, CV_8S=1, CV_16U=2, CV_16S=3, CV_32S=4, CV_32F=5, CV_64F=6 };<br>而多通道类型可以用以下选择方式决定：</li>
<li>CV_8UC1 … CV_64FC4 常量(通道数为1-4)</li>
<li>CV_8UC(n) … CV_64FC(n) or CV_MAKETYPE(CV_8U, n) … CV_MAKETYPE(CV_64F, n) 宏，当通道数超过4或者在编译时无法确定<br>范例：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mat <span class="function">mtx</span>(3, 3, CV_32F); <span class="comment">// make a 3x3 floating-point matrix</span></span><br><span class="line">Mat <span class="function">cmtx</span>(10, 1, CV_64FC2); <span class="comment">// make a 10x1 2-channel floating-point</span></span><br><span class="line">                           <span class="comment">// matrix (10-element complex vector)</span></span><br><span class="line">Mat <span class="function">img</span>(<span class="function">Size</span>(1920, 1080), CV_8UC3); <span class="comment">// make a 3-channel (color) image</span></span><br><span class="line">                                    <span class="comment">// of 1920 columns and 1080 rows.</span></span><br><span class="line">Mat <span class="function">grayscale</span>(image<span class="class">.size</span>(), <span class="function">CV_MAKETYPE</span>(image<span class="class">.depth</span>(), 1)); <span class="comment">// make a 1-channel image of</span></span><br><span class="line">                                                            <span class="comment">// the same size and same</span></span><br><span class="line">                                                            <span class="comment">// channel type as img</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>而拥有更复杂元素的数组是无法被opencv库构造和处理的。另外，每个函数和方法都只能够处理所有可能的数组类型中的一部分。通常情况下算法越复杂，能够支持的数据格式越少。<br>以下是一些典型的例子：</p>
<pre><code>* 人脸检测算法只能处理8位的灰度图或者彩色图
* 线性代数函数和大多数的机器学习算法都只能处理浮点类型的数组。
* 基本的函数如cv::add，支持所有的数据类型
* 彩色空间转换函数支持8位无符号整数，16位无符号整数和32位浮点类型。
</code></pre><p>每个函数的支持类型的子集都已经从实践需要中预定义了，而且可能在未来因为新的需要而扩展。</p>
<ul>
<li><code>输入数组和输出数组</code><br> 许多opencv的函数处理2维和多维的数字数组。通常，一些函数采用cpp::class:Mat 作为参数，但是在一些情况下，使用std::vector(例如一个指针集合) 或者Matx&lt;&gt;（例如一个3*3矩阵）是更方便的。为了避免API中的过多的复制，特殊的“代理proxy”类便出现了。最基本的“代理”类是InputArray，在一个函数输入中，他被用于传递只读数组，从InputArrray派生出来的OutputArray类被用于为一个函数确定一个输出数组。通常，你不需要关注其内在类型，它将会自动工作。你可以假设不是使用InputArray和OutputArray，而是使用Mat, std::vector&lt;&gt;, Matx&lt;&gt;, 或者是标量。当一个函数有可选的输入或者输出数组时，你没有该数组，可以传递cv::noArray()。</li>
<li><p><code>错误处理</code><br> opencv使用exceptions来标识重要的错误。当输入数据有一个正确的格式而且属于特定的值范围，但是因为某些原因（如最优化算法没有收敛）算法不能成功执行，它会返回一个特殊的错误码（典型情况是一个boolean值）。<br> exceptions可以是cv::Exception 类或者是它的派生类，而cv::Exception 是std::Exception的派生类。所以它可以在代码中使用标准c++库中的部分优雅的处理。<br> exception 是典型的使用CV_Error(errcode, description)宏，或者它的CV<em>Error</em>(errcode, printf-spec, (printf-args)),或者CV_Assert(condition)宏。对于性能至关重要的代码，使用CV_DbgAssert(condition)。因为自动内存分配，为了防止突然间的错误所有的内部的内存区都是自动解除分配：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// call OpenCV</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( cv::Exception&amp; e )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* err_msg = e.what();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"exception caught: "</span> &lt;&lt; err_msg &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>多线程</code><br> 当前opencv的实现是 re-enterable  ，就是说，相同的函数，一个类实例的相同的常量方法，或者不同的类的相同的非常量方法都可以在不同的线程中被调用。相同的cv::Mat可以在不同的线程中被使用，因为引用计数操作使用了the architecture-specific atomic instructions.</p>
</li>
</ul>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/opencv2-x-学习笔记/">opencv2.x 学习笔记</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://yoursite.com/2015/12/21/一，opencv2.x介绍/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/opencv2-x-学习笔记/">opencv2.x 学习笔记</a><small>5</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 kongsicong
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>