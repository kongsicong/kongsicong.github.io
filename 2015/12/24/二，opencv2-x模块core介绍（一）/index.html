<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>opencv2.x模块core介绍（一） | 孔小葱的博客</title>
  <meta name="author" content="kongsicong">
  
  <meta name="description" content="一，opencv模块core内容第一部分——Basic Structures（基本数据结构）该模块中包含了opencv所利用到的最基本的数据结构，是opencv最基础最核心，也是最需要掌握的内容，本章节主要介绍opencv2.x基于c++的类，只是顺带提一下opencv1.x中的基于c语言类型的数据">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="opencv2.x模块core介绍（一）"/>
  <meta property="og:site_name" content="孔小葱的博客"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="孔小葱的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">孔小葱的博客</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">存档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-24T04:57:29.000Z"><a href="/2015/12/24/二，opencv2-x模块core介绍（一）/">2015-12-24</a></time>
      
      
  
    <h1 class="title">opencv2.x模块core介绍（一）</h1>
  

    </header>
    <div class="entry">
      
        <h2 id="u4E00_uFF0Copencv_u6A21_u5757core_u5185_u5BB9_u7B2C_u4E00_u90E8_u5206_u2014_u2014Basic_Structures_uFF08_u57FA_u672C_u6570_u636E_u7ED3_u6784_uFF09"><a href="#u4E00_uFF0Copencv_u6A21_u5757core_u5185_u5BB9_u7B2C_u4E00_u90E8_u5206_u2014_u2014Basic_Structures_uFF08_u57FA_u672C_u6570_u636E_u7ED3_u6784_uFF09" class="headerlink" title="一，opencv模块core内容第一部分——Basic Structures（基本数据结构）"></a>一，opencv模块core内容第一部分——Basic Structures（基本数据结构）</h2><p>该模块中包含了opencv所利用到的最基本的数据结构，是opencv最基础最核心，也是最需要掌握的内容，本章节主要介绍opencv2.x基于c++的类，只是顺带提一下opencv1.x中的基于c语言类型的数据结构。<br>opencv2.x中最基础的数据类型有如下几个：<br>DataType——数据类型<br>Point<em>,Point3</em>——点（x，y，z）<br>Size<em>——尺寸（width*heigth）<br>Rect</em>,RotatedRect——矩形（x，y，width，height）<br>TermCriteria——终止条件<br>Matx——小矩阵<br>Vec——向量<br>Scalar<em>——标量<br>Range——范围<br>Ptr——指针<br>Mat,Mat</em>——矩阵<code>（最重要，最核心）</code><br>InputArray,OutputArray——输入输出数组<br>NartMatIterator——矩阵迭代<br>SparseMat,SparseMat_——稀疏矩阵<br>Algorithm——算法</p>
<hr>
<h2 id="u4E8C_uFF0CDataType"><a href="#u4E8C_uFF0CDataType" class="headerlink" title="二，DataType"></a>二，DataType</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB_uFF1A"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB_uFF1A" class="headerlink" title="数据类型简介："></a>数据类型简介：</h3><p>该类是opencv的最原始的数据类型，opencv的基本的数据类型有<code>unsigned char, bool, signed char, unsigned short, signed short, int , float, double 或者是这些类型的多个元素的组合（rgb，三通道数据类型）</code>。以上列表中任何原始数据类型都可以被<code>CV_ &lt;bit-depth&gt;{U|S|F}C(&lt;number_of_channels&gt;)</code>来定义。例如，<code>uchar——CV_8UC1，3个元素的浮点元组——CV_32FC3</code>等等。一个通用的能够存储这样一个原始数据类型的opencv结构就是Vec。这样的数据类型的实例可以被存储在std::vector, Mat, Mat<em>, SparseMat, SparseMat</em>, 或者是任何其他能偶存储Vec实例的容器类。<br><code>结论:DataType就是opencv最基本的数据类型，</code>CV_8UC1<code>之类的东西。</code></p>
<h3 id="u7C7B_u5B9A_u4E49"><a href="#u7C7B_u5B9A_u4E49" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> DataType&lt;uchar&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> uchar value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> work_type;</span><br><span class="line">    <span class="keyword">typedef</span> uchar channel_type;</span><br><span class="line">    <span class="keyword">enum</span> &#123; channel_type = CV_8U, channels = <span class="number">1</span>, fmt=<span class="string">'u'</span>, type = CV_8U &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; DataType&lt;<span class="built_in">std</span>::<span class="keyword">complex</span>&lt;_Tp&gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">complex</span>&lt;_Tp&gt; value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">complex</span>&lt;_Tp&gt; work_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp channel_type;</span><br><span class="line">    <span class="comment">// DataDepth is another helper trait class</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; depth = DataDepth&lt;_Tp&gt;::value, channels=<span class="number">2</span>,</span><br><span class="line">        fmt=(channels-<span class="number">1</span>)*<span class="number">256</span>+DataDepth&lt;_Tp&gt;::fmt,</span><br><span class="line">        type=CV_MAKETYPE(depth, channels) &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这个类的作用就是讲可确定编译时间类型的数据转化为opencv特定的可编译数据类型。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocates a 30x40 floating-point matrix</span></span><br><span class="line"><span class="function">Mat <span class="title">A</span><span class="params">(<span class="number">30</span>, <span class="number">40</span>, DataType&lt;<span class="keyword">float</span>&gt;::type)</span></span>;</span><br><span class="line"></span><br><span class="line">Mat B = Mat_&lt;<span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; &gt;(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// the statement below will print 6, 2 /*, that is depth == CV_64F, channels == 2 */</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; B.depth() &lt;&lt; <span class="string">", "</span> &lt;&lt; B.channels() &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>在平常的使用中，一般不会直接使用这个类的对象，而是直接使用<code>CV_8UC3</code>等预定义常量</p>
<hr>
<h2 id="u4E09_uFF0CPoint_2CPoint3"><a href="#u4E09_uFF0CPoint_2CPoint3" class="headerlink" title="三，Point,Point3"></a>三，Point<em>,Point3</em></h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>这两个类就是为了描述计算机图像中的点，Point<em>描述的是2维的点（x, y）（在opencv1.x中对应的是CvPoint和CvPoint2D32f）,Point3</em>描述的是3维的点(x, y, z) 。</p>
<h3 id="u7C7B_u5B9A_u4E49-1"><a href="#u7C7B_u5B9A_u4E49-1" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Point_</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// various constructors</span></span><br><span class="line">    Point_();</span><br><span class="line">    Point_(_Tp _x, _Tp _y);</span><br><span class="line">    Point_(<span class="keyword">const</span> Point_&amp; pt);</span><br><span class="line">    Point_(<span class="keyword">const</span> CvPoint&amp; pt);</span><br><span class="line">    Point_(<span class="keyword">const</span> CvPoint2D32f&amp; pt);</span><br><span class="line">    Point_(<span class="keyword">const</span> Size_&lt;_Tp&gt;&amp; sz);</span><br><span class="line">    Point_(<span class="keyword">const</span> Vec&lt;_Tp, <span class="number">2</span>&gt;&amp; v);</span><br><span class="line"></span><br><span class="line">    Point_&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Point_&amp; pt);</span><br><span class="line">    <span class="comment">//! conversion to another data type</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Point_&lt;_Tp2&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion to the old-style C structures</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvPoint</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvPoint2D32f</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">operator</span> Vec&lt;_Tp, <span class="number">2</span>&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! dot product</span></span><br><span class="line">    _<span class="function">Tp <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! dot product computed in double-precision arithmetics</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">ddot</span><span class="params">(<span class="keyword">const</span> Point_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! cross-product</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! checks whether the point is inside the specified rectangle</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">inside</span><span class="params">(<span class="keyword">const</span> Rect_&lt;_Tp&gt;&amp; r)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    _Tp x, y; <span class="comment">//&lt; the point coordinates</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中以Point_模板类为原型预定义了许多表示2维坐标点的类供我们使用：如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Point_&lt;<span class="keyword">int</span>&gt; Point2i;</span><br><span class="line"><span class="keyword">typedef</span> Point2i Point;</span><br><span class="line"><span class="keyword">typedef</span> Point_&lt;<span class="keyword">float</span>&gt; Point2f;</span><br><span class="line"><span class="keyword">typedef</span> Point_&lt;<span class="keyword">double</span>&gt; Point2d;</span><br></pre></td></tr></table></figure></p>
<p>使用范例：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Point2f</span> a(<span class="number">0</span>.3f, <span class="number">0</span>.f), b(<span class="number">0</span>.f, <span class="number">0</span>.4f);</span><br><span class="line"><span class="title">Point</span> pt = (a + b)*<span class="number">10</span>.f;</span><br><span class="line"><span class="title">cout</span> &lt;&lt; pt.x &lt;&lt; <span class="string">", "</span> &lt;&lt; pt.y &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>Point_类实例能够进行多种运算：<br>pt1 = pt2 + pt3;<br>pt1 = pt2 - pt3;<br>pt1 = pt2 <em> a;<br>pt1 = a </em> pt2;<br>pt1 += pt2;<br>pt1 -= pt2;<br>pt1 *= a;<br>double value = norm(pt); // L2 norm<br>pt1 == pt2;<br>pt1 != pt2;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Point3_</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// various constructors</span></span><br><span class="line">    Point3_();</span><br><span class="line">    Point3_(_Tp _x, _Tp _y, _Tp _z);</span><br><span class="line">    Point3_(<span class="keyword">const</span> Point3_&amp; pt);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Point3_</span><span class="params">(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt)</span></span>;</span><br><span class="line">    Point3_(<span class="keyword">const</span> CvPoint3D32f&amp; pt);</span><br><span class="line">    Point3_(<span class="keyword">const</span> Vec&lt;_Tp, <span class="number">3</span>&gt;&amp; v);</span><br><span class="line"></span><br><span class="line">    Point3_&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Point3_&amp; pt);</span><br><span class="line">    <span class="comment">//! conversion to another data type</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Point3_&lt;_Tp2&gt;() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">//! conversion to the old-style CvPoint...</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvPoint3D32f</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! conversion to cv::Vec&lt;&gt;</span></span><br><span class="line">    <span class="keyword">operator</span> Vec&lt;_Tp, <span class="number">3</span>&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! dot product</span></span><br><span class="line">    _<span class="function">Tp <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point3_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! dot product computed in double-precision arithmetics</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">ddot</span><span class="params">(<span class="keyword">const</span> Point3_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! cross product of the 2 3D points</span></span><br><span class="line">    <span class="function">Point3_ <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point3_&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    _Tp x, y, z; <span class="comment">//&lt; the point coordinates</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>同样的，Point3_也预定义了一些类让我们直接使用：如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Point3_&lt;<span class="keyword">int</span>&gt; Point3i;</span><br><span class="line"><span class="keyword">typedef</span> Point3_&lt;<span class="keyword">float</span>&gt; Point3f;</span><br><span class="line"><span class="keyword">typedef</span> Point3_&lt;<span class="keyword">double</span>&gt; Point3d;</span><br></pre></td></tr></table></figure></p>
<p>点   类型的数据结构是opencv中很重要的类型之一。</p>
<hr>
<h2 id="u56DB_uFF0CSize"><a href="#u56DB_uFF0CSize" class="headerlink" title="四，Size_"></a>四，Size_</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-1"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-1" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>该数据类型主要用来表示一定大小的矩形框，它的最主要的数据成员就是width和height了。在opencv1.x中和Size_有相同作用的数据结构就是CvSize和CvSize2D32f了。</p>
<h3 id="u7C7B_u5B9A_u4E49-2"><a href="#u7C7B_u5B9A_u4E49-2" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Size_</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! various constructors</span></span><br><span class="line">    Size_();</span><br><span class="line">    Size_(_Tp _width, _Tp _height);</span><br><span class="line">    Size_(<span class="keyword">const</span> Size_&amp; sz);</span><br><span class="line">    Size_(<span class="keyword">const</span> CvSize&amp; sz);</span><br><span class="line">    Size_(<span class="keyword">const</span> CvSize2D32f&amp; sz);</span><br><span class="line">    Size_(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt);</span><br><span class="line"></span><br><span class="line">    Size_&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Size_&amp; sz);</span><br><span class="line">    <span class="comment">//! the area (width*height)</span></span><br><span class="line">    _<span class="function">Tp <span class="title">area</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion of another data type.</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Size_&lt;_Tp2&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion to the old-style OpenCV types</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvSize2D32f</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    _Tp width, height; <span class="comment">// the width and the height</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然同Point<em>一样，Size</em>也预定义了一些数据类型供我们使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Size_&lt;<span class="keyword">int</span>&gt; Size2i;</span><br><span class="line"><span class="keyword">typedef</span> Size2i Size;</span><br><span class="line"><span class="keyword">typedef</span> Size_&lt;<span class="keyword">float</span>&gt; Size2f;</span><br></pre></td></tr></table></figure></p>
<p>该数据类型时opencv中我们最常用的数据类型之一。</p>
<hr>
<h2 id="u4E94_uFF0CRect__uFF0CRotatedRect"><a href="#u4E94_uFF0CRect__uFF0CRotatedRect" class="headerlink" title="五，Rect_，RotatedRect"></a>五，Rect_，RotatedRect</h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-2"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-2" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>该类则是点Point和尺寸Size的合体了，代表着一副图像中在某个特定位置的矩形框。它最主要的数据成员就是（x, y, width, height），（x, y）表示矩形框左上顶点的位置，而RotatedRect则代表着一个旋转以后的矩形框，除了和矩形框拥有相同的（x, y, width, height）以外，还多了一个angel（旋转角度）的数据成员：<br><img src="./1450936414855.png" alt="Alt text"></p>
<h3 id="u7C7B_u5B9A_u4E49-3"><a href="#u7C7B_u5B9A_u4E49-3" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> CV_EXPORTS Rect_</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! various constructors</span></span><br><span class="line">    Rect_();</span><br><span class="line">    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);</span><br><span class="line">    Rect_(<span class="keyword">const</span> Rect_&amp; r);</span><br><span class="line">    Rect_(<span class="keyword">const</span> CvRect&amp; r);</span><br><span class="line">    Rect_(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; org, <span class="keyword">const</span> Size_&lt;_Tp&gt;&amp; sz);</span><br><span class="line">    Rect_(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt1, <span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt2);</span><br><span class="line"></span><br><span class="line">    Rect_&amp; <span class="keyword">operator</span> = ( <span class="keyword">const</span> Rect_&amp; r );</span><br><span class="line">    <span class="comment">//! the top-left corner</span></span><br><span class="line">    Point_&lt;_Tp&gt; tl() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">//! the bottom-right corner</span></span><br><span class="line">    Point_&lt;_Tp&gt; br() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! size (width, height) of the rectangle</span></span><br><span class="line">    Size_&lt;_Tp&gt; size() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">//! area (width*height) of the rectangle</span></span><br><span class="line">    _<span class="function">Tp <span class="title">area</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! conversion to another data type</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Rect_&lt;_Tp2&gt;() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">//! conversion to the old-style CvRect</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvRect</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! checks whether the rectangle contains the point</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    _Tp x, y, width, height; <span class="comment">//&lt; the top-left corner, as well as width and height of the rectangle</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该模版类预定义了一些类，来供我们使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Rect_&lt;<span class="keyword">int</span>&gt; Rect;</span><br></pre></td></tr></table></figure></p>
<p>该类实例能够进行多种数学运算如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rect</span> = <span class="built_in">rect</span> + <span class="built_in">point</span> (矩形位置平移)</span><br><span class="line"><span class="built_in">rect</span> = <span class="built_in">rect</span> + <span class="built_in">size</span> (扩大或缩小矩形)</span><br><span class="line"><span class="built_in">rect</span> += <span class="built_in">point</span>, <span class="built_in">rect</span> -= <span class="built_in">point</span>, <span class="built_in">rect</span> += <span class="built_in">size</span>, <span class="built_in">rect</span> -= <span class="built_in">size</span> </span><br><span class="line"><span class="built_in">rect</span> = rect1 &amp; rect2</span><br><span class="line"><span class="built_in">rect</span> = rect1 | rect2 </span><br><span class="line"><span class="built_in">rect</span> &amp;= rect1, <span class="built_in">rect</span> |= rect1 </span><br><span class="line"><span class="built_in">rect</span> == rect1, <span class="built_in">rect</span> != rect1</span><br></pre></td></tr></table></figure></p>
<p>该类型是opencv中最常用的数据类型之一。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">CV_EXPORTS</span> <span class="title">RotatedRect</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! various constructors</span></span><br><span class="line">    RotatedRect();</span><br><span class="line">    RotatedRect(<span class="keyword">const</span> Point2f&amp; center, <span class="keyword">const</span> Size2f&amp; size, <span class="keyword">float</span> angle);</span><br><span class="line">    RotatedRect(<span class="keyword">const</span> CvBox2D&amp; box);</span><br><span class="line">    <span class="comment">//! returns 4 vertices of the rectangle</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">points</span>(<span class="params">Point2f pts[]</span>) <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! returns the minimal up-right rectangle containing the rotated rectangle</span></span><br><span class="line">    <span class="function">Rect <span class="title">boundingRect</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! conversion to the old-style CvBox2D structure</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvBox2D</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</span><br><span class="line">    Point2f center; <span class="comment">//&lt; the rectangle mass center</span></span><br><span class="line">    Size2f size;    <span class="comment">//&lt; width and height of the rectangle</span></span><br><span class="line">    <span class="keyword">float</span> angle;    <span class="comment">//&lt; the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>旋转矩形使用范例如下：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Mat image(200, 200, CV_8UC3, Scalar(0))<span class="comment">;</span></span><br><span class="line">RotatedRect rRect = RotatedRect(Point2f(<span class="number">100,100</span>), Size2f(100,50), 30)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Point2f vertices[4]<span class="comment">;</span></span><br><span class="line">rRect.points(vertices)<span class="comment">;</span></span><br><span class="line">for (int i = 0<span class="comment">; i &lt; 4; i++)</span></span><br><span class="line">    line(image, vertices[i], vertices[(i+1)%4], Scalar(<span class="number">0,255,0</span>))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Rect brect = rRect.boundingRect()<span class="comment">;</span></span><br><span class="line">rectangle(image, brect, Scalar(<span class="number">255,0,0</span>))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">imshow("rectangles", image)<span class="comment">;</span></span><br><span class="line">waitKey(0)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="u516D_uFF0CMat_2C_Matx_2C_Mat_2C_SparseMat_2C_SparseMat"><a href="#u516D_uFF0CMat_2C_Matx_2C_Mat_2C_SparseMat_2C_SparseMat" class="headerlink" title="六，Mat, Matx, Mat, SparseMat, SparseMat"></a>六，<code>Mat</code>, Matx, Mat<em>, SparseMat, SparseMat</em></h2><h3 id="u6570_u636E_u7C7B_u578B_u7B80_u4ECB-3"><a href="#u6570_u636E_u7C7B_u578B_u7B80_u4ECB-3" class="headerlink" title="数据类型简介"></a>数据类型简介</h3><p>矩阵是计算机视觉，计算机图像处理中最终要的概念。由于图像在计算机中都采用像素点来表示，一副图像是由width*height个像素点来组成，这所有的点组合起来就像是数学中的Mat（矩阵）。将矩阵的使用学好了，对于计算机图像处理，计算机视觉的认知就算是真正的开始了。毫无疑问，矩阵（Mat）这种数据类型是opencv最核心的数据类型，没有之一。然而为了应对各种图像的情况，opencv定义了多种类型的矩阵供我们使用。以下便让我一一介绍：</p>
<h3 id="u7C7B_u5B9A_u4E49-4"><a href="#u7C7B_u5B9A_u4E49-4" class="headerlink" title="类定义"></a>类定义</h3><ul>
<li>Mat（矩阵）<br>该矩阵代表着n维数字类型的单通道或者是多通道的数组类型的数据。它可以存储实数或者是复数向量和矩阵，灰度图或者彩色图，立体像素卷，向量域，点云，直方图（高维的直方图最好用稀疏矩阵SparseMat来存储）等等。数组M的数据位置被数组M.step[]定义，所以访问矩阵中的M(i0,i1,···,in-1),就可以通过如下公式访问：<figure class="highlight"><figcaption><span>= M.data + M.step[0]*i_0 + M.step[1]*i_1 + ... + M.step[M.dims-1]*i_&#123;M.dims-1&#125; ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#23545;&#20110;&#20108;&#32500;&#30697;&#38453;&#26469;&#35828;&#65292;&#35775;&#38382;&#20854;&#20013;&#30340;&#20803;&#32032;&#23601;&#26159;&#10;```addr(M_&#123;i,j&#125;) = M.data + M.step[0]*i + M.step[1]*j</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在opencv1.x中与矩阵Mat相对应的数据类型就是CvMat, IplImage, 和CvMatND等,其类定义如下：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class CV_EXPORTS Mat</span><br><span class="line">&#123;<span class="keyword"></span><br><span class="line">public</span>:</span><br><span class="line">    // ... a lot of methods ...</span><br><span class="line"><span class="keyword">    .</span>..</span><br><span class="line"></span><br><span class="line">    /*! includes several bit-fields:</span><br><span class="line">         - the magic signature</span><br><span class="line">         - continuity flag</span><br><span class="line">         - depth</span><br><span class="line">         - number of channels</span><br><span class="line">     */</span><br><span class="line">   <span class="instruction"> int </span>flags;</span><br><span class="line">    //! the<span class="instruction"> array </span>dimensionality, &gt;= 2</span><br><span class="line">   <span class="instruction"> int </span>dims;</span><br><span class="line">    //! the number of rows<span class="instruction"> and </span>columns<span class="instruction"> or </span>(-1, -1<span class="function">)</span> when the<span class="instruction"> array </span>has more than 2 dimensions</span><br><span class="line">   <span class="instruction"> int </span>rows, cols;</span><br><span class="line">    //! pointer to the data</span><br><span class="line">    uchar* data;</span><br><span class="line"></span><br><span class="line">    //! pointer to the reference counter;</span><br><span class="line">    // when<span class="instruction"> array </span>points to user-allocated data, the pointer is NULL</span><br><span class="line">    int* refcount;</span><br><span class="line"></span><br><span class="line">    // other members</span><br><span class="line"><span class="keyword">    .</span>..</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一般情况下表示一副图像只需要二维矩阵就够了，要么一个像素点事灰度值，要么一个像素点是一个向量，存储rgb三色。<br>基本的构造一个Mat对象的方法如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make a 7x7 complex matrix filled with 1+3j.</span></span><br><span class="line"><span class="keyword">Mat</span> <span class="literal">M</span>(7,7,CV_32FC2,<span class="literal">Scalar</span>(1,3));</span><br><span class="line"></span><br><span class="line"><span class="comment">// and now turn M to a 100x60 15-channel 8-bit matrix.</span></span><br><span class="line"><span class="comment">// The old content will be deallocated</span></span><br><span class="line"><span class="keyword">M</span>.create(100,60,CV_8UC(15));</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a 100x100x100 8-bit array</span></span><br><span class="line">int sz[] = &#123;100, 100, 100&#125;;</span><br><span class="line"><span class="keyword">Mat</span> bigCube(3, sz, CV_8U, <span class="keyword">Scalar</span>::all(0));</span><br><span class="line"><span class="comment">// add the 5-th row, multiplied by 3 to the 3rd row</span></span><br><span class="line"><span class="keyword">M</span>.row(3) = <span class="keyword">M</span>.row(3) + <span class="keyword">M</span>.row(5)*3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now copy the 7-th column to the 1-st column</span></span><br><span class="line"><span class="comment">// M.col(1) = M.col(7); // this will not work</span></span><br><span class="line"><span class="keyword">Mat</span> M1 = <span class="keyword">M</span>.col(1);</span><br><span class="line"><span class="keyword">M</span>.col(7).copyTo(M1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new 320x240 image</span></span><br><span class="line"><span class="keyword">Mat</span> img(Size(320,240),CV_8UC3);</span><br><span class="line"><span class="comment">// select a ROI</span></span><br><span class="line"><span class="keyword">Mat</span> roi(img, Rect(10,10,100,100));</span><br><span class="line"><span class="comment">// fill the ROI with (0,255,0) (which is green in RGB space);</span></span><br><span class="line"><span class="comment">// the original 320x240 image will be modified</span></span><br><span class="line">roi = <span class="literal">Scalar</span>(0,255,0);</span><br><span class="line"><span class="keyword">Mat</span> A = <span class="keyword">Mat</span>::eye(10, 10, CV_32S);</span><br><span class="line"><span class="comment">// extracts A columns, 1 (inclusive) to 3 (exclusive).</span></span><br><span class="line"><span class="keyword">Mat</span> B = A(<span class="keyword">Range</span>::all(), <span class="keyword">Range</span>(1, 3));</span><br><span class="line"><span class="comment">// extracts B rows, 5 (inclusive) to 9 (exclusive).</span></span><br><span class="line"><span class="comment">// that is, C ~ A(Range(5, 9), Range(1, 3))</span></span><br><span class="line"><span class="keyword">Mat</span> C = B(<span class="keyword">Range</span>(5, 9), <span class="keyword">Range</span>::all());</span><br><span class="line">Size size; Point ofs;</span><br><span class="line">C.locateROI(size, ofs);</span><br><span class="line"><span class="comment">// size will be (width=10,height=10) and the ofs will be (x=1, y=5)</span></span><br></pre></td></tr></table></figure></p>
<p>Mat的构造函数如下：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">C++: Mat::Mat()</span><br><span class="line">C++: Mat::Mat(int rows, int cols, int type)</span><br><span class="line">C++: Mat::Mat(Size size, int type)</span><br><span class="line">C++: Mat::Mat(int rows, int cols, int type, <span class="keyword">const</span> Scalar&amp; s)</span><br><span class="line">C++: Mat::Mat(Size size, int type, <span class="keyword">const</span> Scalar&amp; s)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> Mat&amp; m)</span><br><span class="line">C++: Mat::Mat(int rows, int cols, int type, void* data, size_t <span class="keyword">step</span>=AUTO_STEP)</span><br><span class="line">C++: Mat::Mat(Size size, int type, void* data, size_t <span class="keyword">step</span>=AUTO_STEP)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> Mat&amp; m, <span class="keyword">const</span> Range&amp; rowRange, <span class="keyword">const</span> Range&amp; colRange=Range::all() )</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> Mat&amp; m, <span class="keyword">const</span> Rect&amp; roi)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> CvMat* m, bool copyData=<span class="literal">false</span>)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> IplImage* img, bool copyData=<span class="literal">false</span>)</span><br><span class="line">C++: template&lt;typename T, int n&gt; <span class="keyword">explicit</span> Mat::Mat(<span class="keyword">const</span> Vec&lt;T, n&gt;&amp; vec, bool copyData=<span class="literal">true</span>)</span><br><span class="line">C++: template&lt;typename T, int m, int n&gt; <span class="keyword">explicit</span> Mat::Mat(<span class="keyword">const</span> Matx&lt;T, m, n&gt;&amp; vec, bool copyData=<span class="literal">true</span>)</span><br><span class="line">C++: template&lt;typename T&gt; <span class="keyword">explicit</span> Mat::Mat(<span class="keyword">const</span> vector&lt;T&gt;&amp; vec, bool copyData=<span class="literal">false</span>)</span><br><span class="line">C++: Mat::Mat(int ndims, <span class="keyword">const</span> int* sizes, int type)</span><br><span class="line">C++: Mat::Mat(int ndims, <span class="keyword">const</span> int* sizes, int type, <span class="keyword">const</span> Scalar&amp; s)</span><br><span class="line">C++: Mat::Mat(int ndims, <span class="keyword">const</span> int* sizes, int type, void* data, <span class="keyword">const</span> size_t* steps=<span class="number">0</span>)</span><br><span class="line">C++: Mat::Mat(<span class="keyword">const</span> Mat&amp; m, <span class="keyword">const</span> Range* ranges)</span><br><span class="line">Parameters:	</span><br><span class="line">ndims – Array dimensionality.</span><br><span class="line">rows – Number <span class="keyword">of</span> rows <span class="keyword">in</span> a <span class="number">2</span>D array.</span><br><span class="line">cols – Number <span class="keyword">of</span> columns <span class="keyword">in</span> a <span class="number">2</span>D array.</span><br><span class="line">roi – Region <span class="keyword">of</span> interest.</span><br><span class="line">size – <span class="number">2</span>D array size: Size(cols, rows) . <span class="keyword">In</span> the Size() constructor, the number <span class="keyword">of</span> rows <span class="keyword">and</span> the number <span class="keyword">of</span> columns go <span class="keyword">in</span> the reverse <span class="keyword">order</span>.</span><br><span class="line">sizes – Array <span class="keyword">of</span> integers specifying an n-dimensional array shape.</span><br><span class="line">type – Array type. Use CV_8UC1, ..., CV_64FC4 <span class="keyword">to</span> create <span class="number">1</span>-<span class="number">4</span> channel matrices, <span class="keyword">or</span> CV_8UC(n), ..., CV_64FC(n) <span class="keyword">to</span> create multi-channel (up <span class="keyword">to</span> CV_CN_MAX channels) matrices.</span><br><span class="line">s – An <span class="keyword">optional</span> value <span class="keyword">to</span> initialize <span class="keyword">each</span> matrix element <span class="keyword">with</span>. <span class="keyword">To</span> <span class="keyword">set</span> all the matrix elements <span class="keyword">to</span> the particular value after the construction, use the assignment <span class="keyword">operator</span> Mat::<span class="keyword">operator</span>=(<span class="keyword">const</span> Scalar&amp; value) .</span><br><span class="line">data – Pointer <span class="keyword">to</span> the user data. Matrix constructors that <span class="keyword">take</span> data <span class="keyword">and</span> <span class="keyword">step</span> parameters <span class="keyword">do</span> <span class="keyword">not</span> allocate matrix data. Instead, they just initialize the matrix header that points <span class="keyword">to</span> the specified data, which means that no data <span class="keyword">is</span> copied. This operation <span class="keyword">is</span> very efficient <span class="keyword">and</span> can be used <span class="keyword">to</span> process external data <span class="keyword">using</span> OpenCV functions. The external data <span class="keyword">is</span> <span class="keyword">not</span> automatically deallocated, so you should <span class="keyword">take</span> care <span class="keyword">of</span> it.</span><br><span class="line"><span class="keyword">step</span> – Number <span class="keyword">of</span> bytes <span class="keyword">each</span> matrix row occupies. The value should include the padding bytes at the <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">each</span> row, <span class="keyword">if</span> any. <span class="keyword">If</span> the parameter <span class="keyword">is</span> missing (<span class="keyword">set</span> <span class="keyword">to</span> AUTO_STEP ), no padding <span class="keyword">is</span> assumed <span class="keyword">and</span> the actual <span class="keyword">step</span> <span class="keyword">is</span> calculated <span class="keyword">as</span> cols*elemSize() . See Mat::elemSize() .</span><br><span class="line">steps – Array <span class="keyword">of</span> ndims-<span class="number">1</span> steps <span class="keyword">in</span> <span class="keyword">case</span> <span class="keyword">of</span> a multi-dimensional array (the last <span class="keyword">step</span> <span class="keyword">is</span> always <span class="keyword">set</span> <span class="keyword">to</span> the element size). <span class="keyword">If</span> <span class="keyword">not</span> specified, the matrix <span class="keyword">is</span> assumed <span class="keyword">to</span> be continuous.</span><br><span class="line">m – Array that (<span class="keyword">as</span> a whole <span class="keyword">or</span> partly) <span class="keyword">is</span> assigned <span class="keyword">to</span> the constructed matrix. No data <span class="keyword">is</span> copied <span class="keyword">by</span> these constructors. Instead, the header pointing <span class="keyword">to</span> m data <span class="keyword">or</span> its <span class="keyword">sub</span>-array <span class="keyword">is</span> constructed <span class="keyword">and</span> associated <span class="keyword">with</span> it. The reference counter, <span class="keyword">if</span> any, <span class="keyword">is</span> incremented. So, <span class="keyword">when</span> you modify the matrix formed <span class="keyword">using</span> such a constructor, you also modify the corresponding elements <span class="keyword">of</span> m . <span class="keyword">If</span> you want <span class="keyword">to</span> have an independent copy <span class="keyword">of</span> the <span class="keyword">sub</span>-array, use Mat::clone() .</span><br><span class="line">img – Pointer <span class="keyword">to</span> the old-style IplImage image <span class="keyword">structure</span>. <span class="keyword">By</span> <span class="keyword">default</span>, the data <span class="keyword">is</span> <span class="keyword">shared</span> between the original image <span class="keyword">and</span> the <span class="keyword">new</span> matrix. But <span class="keyword">when</span> copyData <span class="keyword">is</span> <span class="keyword">set</span>, the full copy <span class="keyword">of</span> the image data <span class="keyword">is</span> created.</span><br><span class="line">vec – STL vector whose elements form the matrix. The matrix has a <span class="built_in">single</span> column <span class="keyword">and</span> the number <span class="keyword">of</span> rows equal <span class="keyword">to</span> the number <span class="keyword">of</span> vector elements. Type <span class="keyword">of</span> the matrix matches the type <span class="keyword">of</span> vector elements. The constructor can handle arbitrary types, <span class="keyword">for</span> which there <span class="keyword">is</span> a properly declared DataType . This means that the vector elements must be primitive numbers <span class="keyword">or</span> uni-type numerical tuples <span class="keyword">of</span> numbers. Mixed-type structures are <span class="keyword">not</span> supported. The corresponding constructor <span class="keyword">is</span> <span class="keyword">explicit</span>. Since STL vectors are <span class="keyword">not</span> automatically converted <span class="keyword">to</span> Mat instances, you should write Mat(vec) explicitly. Unless you copy the data <span class="keyword">into</span> the matrix ( copyData=<span class="literal">true</span> ), no <span class="keyword">new</span> elements will be added <span class="keyword">to</span> the vector because it can potentially yield vector data reallocation, <span class="keyword">and</span>, thus, the matrix data pointer will be invalid.</span><br><span class="line">copyData – Flag <span class="keyword">to</span> specify whether the underlying data <span class="keyword">of</span> the STL vector <span class="keyword">or</span> the old-style CvMat <span class="keyword">or</span> IplImage should be copied <span class="keyword">to</span> (<span class="literal">true</span>) <span class="keyword">or</span> <span class="keyword">shared</span> <span class="keyword">with</span> (<span class="literal">false</span>) the newly constructed matrix. <span class="keyword">When</span> the data <span class="keyword">is</span> copied, the allocated buffer <span class="keyword">is</span> managed <span class="keyword">using</span> Mat reference counting mechanism. <span class="keyword">While</span> the data <span class="keyword">is</span> <span class="keyword">shared</span>, the reference counter <span class="keyword">is</span> NULL, <span class="keyword">and</span> you should <span class="keyword">not</span> deallocate the data <span class="keyword">until</span> the matrix <span class="keyword">is</span> <span class="keyword">not</span> destructed.</span><br><span class="line">rowRange – Range <span class="keyword">of</span> the m rows <span class="keyword">to</span> <span class="keyword">take</span>. <span class="keyword">As</span> usual, the range start <span class="keyword">is</span> inclusive <span class="keyword">and</span> the range <span class="keyword">end</span> <span class="keyword">is</span> exclusive. Use Range::all() <span class="keyword">to</span> <span class="keyword">take</span> all the rows.</span><br><span class="line">colRange – Range <span class="keyword">of</span> the m columns <span class="keyword">to</span> <span class="keyword">take</span>. Use Range::all() <span class="keyword">to</span> <span class="keyword">take</span> all the columns.</span><br><span class="line">ranges – Array <span class="keyword">of</span> selected ranges <span class="keyword">of</span> m along <span class="keyword">each</span> dimensionality.</span><br></pre></td></tr></table></figure></p>
<p>Mat的其他各种成员方法见<a href="http://docs.opencv.org/2.4.11/modules/core/doc/basic_structures.html#mat" target="_blank" rel="external">Mat详解</a></p>
<ul>
<li>Matx（小矩阵）<br>该类型的矩阵为能够确定类型，确定尺寸和确定编译时间的小矩阵。<br>其基本定义如下；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">int</span> m, <span class="keyword">int</span> n&gt; <span class="keyword">class</span> Matx &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">1</span>, <span class="number">2</span>&gt; Matx12f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">2</span>&gt; Matx12d;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">1</span>, <span class="number">6</span>&gt; Matx16f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">6</span>&gt; Matx16d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">1</span>&gt; Matx21f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">1</span>&gt; Matx21d;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">6</span>, <span class="number">1</span>&gt; Matx61f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">1</span>&gt; Matx61d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">2</span>&gt; Matx22f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">2</span>&gt; Matx22d;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">float</span>, <span class="number">6</span>, <span class="number">6</span>&gt; Matx66f;</span><br><span class="line"><span class="keyword">typedef</span> Matx&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">6</span>&gt; Matx66d;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用范例如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matx33f <span class="title">m</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">          <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">          <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(Mat(m*m.t())) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>Mat_</p>
</li>
<li><p>SparseMat（稀疏矩阵）</p>
</li>
<li><p>SparseMat_</p>
</li>
</ul>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/opencv2-x-学习笔记/">opencv2.x 学习笔记</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://yoursite.com/2015/12/24/二，opencv2-x模块core介绍（一）/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/opencv2-x-学习笔记/">opencv2.x 学习笔记</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 kongsicong
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>